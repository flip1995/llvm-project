// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// Previously compiling a recursive CCall would break the TBAA verifier because
// it was emitting a load of the whole struct instead of the individual elements
// RUN: %cheri_purecap_cc1 -no-struct-path-tbaa -emit-llvm -O2 -o - %s | FileCheck %s
// RUN: %cheri_purecap_cc1 -new-struct-path-tbaa -emit-llvm -O2 -o - %s | FileCheck %s
struct {
  void *a;
  void *b;
} c;
__attribute__((cheri_ccall)) __attribute__((cheri_method_class(c))) int
// CHECK-LABEL: define {{[^@]+}}@d
// CHECK-SAME: () local_unnamed_addr addrspace(200) [[ATTR0:#.*]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i64, i64 addrspace(200)* @__cheri_method.c.d, align 8, !invariant.load !2
// CHECK-NEXT:    [[TMP1:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* getelementptr inbounds (%struct.anon, [[STRUCT_ANON:%.*]] addrspace(200)* @c, i64 0, i32 0), align 16
// CHECK-NEXT:    [[TMP2:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* getelementptr inbounds (%struct.anon, [[STRUCT_ANON]] addrspace(200)* @c, i64 0, i32 1), align 16
// CHECK-NEXT:    [[CALL:%.*]] = tail call chericcallcc signext i32 @cheri_invoke(i8 addrspace(200)* [[TMP1]], i8 addrspace(200)* [[TMP2]], i64 zeroext [[TMP0]]) [[ATTR1:#.*]]
// CHECK-NEXT:    ret i32 0
//
d(void) {
  d();
  return 0;
}
