// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_purecap_cc1 -o - -emit-llvm -O0 %s | FileCheck %s
// CHECK-LABEL: @var_annotation(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[B:%.*]] = alloca i32, align 4, addrspace(200)
// CHECK-NEXT:    [[B1:%.*]] = bitcast i32 addrspace(200)* [[B]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @llvm.var.annotation.p200i8(i8 addrspace(200)* [[B1]], i8 addrspace(200)* getelementptr inbounds ([4 x i8], [4 x i8] addrspace(200)* @.str, i32 0, i32 0), i8 addrspace(200)* getelementptr inbounds ([67 x i8], [67 x i8] addrspace(200)* @.str.1, i32 0, i32 0), i32 [[@LINE+4]])
// CHECK-NEXT:    ret void
//
void var_annotation(void) {
  __attribute__((annotate("foo"))) int b;
}

// Should be overloaded and args in AS200
// CHECK: declare void @llvm.var.annotation.p200i8(i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)*, i32) addrspace(200)

// CHECK-LABEL: @ptr_annotation(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VAR:%.*]] = alloca [[STRUCT_ANON:%.*]], align 4, addrspace(200)
// CHECK-NEXT:    [[U:%.*]] = getelementptr inbounds [[STRUCT_ANON]], [[STRUCT_ANON]] addrspace(200)* [[VAR]], i32 0, i32 0
// CHECK-NEXT:    store i32 0, i32 addrspace(200)* [[U]], align 4
// CHECK-NEXT:    [[V:%.*]] = getelementptr inbounds [[STRUCT_ANON]], [[STRUCT_ANON]] addrspace(200)* [[VAR]], i32 0, i32 1
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 addrspace(200)* [[V]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.ptr.annotation.p200i8.p200i8(i8 addrspace(200)* [[TMP0]], i8 addrspace(200)* getelementptr inbounds ([13 x i8], [13 x i8] addrspace(200)* @.str.2, i32 0, i32 0), i8 addrspace(200)* getelementptr inbounds ([67 x i8], [67 x i8] addrspace(200)* @.str.1, i32 0, i32 0), i32 [[@LINE+8]])
// CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[TMP1]] to i32 addrspace(200)*
// CHECK-NEXT:    store i32 0, i32 addrspace(200)* [[TMP2]], align 4
// CHECK-NEXT:    ret i32 0
//
int ptr_annotation(void) {
  struct {
    int u;
    __attribute__((annotate("myannotation"))) int v;
  } var;
  var.u = 0;
  var.v = 0;
  return (0);
}

// Should be overloaded and args in AS200
// CHECK: declare i8 addrspace(200)* @llvm.ptr.annotation.p200i8.p200i8(i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)*, i32) addrspace(200)

// CHECK-LABEL: @builtin_annotation(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca i64, align 8, addrspace(200)
// CHECK-NEXT:    [[Y:%.*]] = alloca i64, align 8, addrspace(200)
// CHECK-NEXT:    store i64 [[X:%.*]], i64 addrspace(200)* [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load i64, i64 addrspace(200)* [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.annotation.i64.p200i8(i64 [[TMP0]], i8 addrspace(200)* getelementptr inbounds ([13 x i8], [13 x i8] addrspace(200)* @.str.3, i32 0, i32 0), i8 addrspace(200)* getelementptr inbounds ([67 x i8], [67 x i8] addrspace(200)* @.str.1, i32 0, i32 0), i32 [[@LINE+9]])
// CHECK-NEXT:    store i64 [[TMP1]], i64 addrspace(200)* [[Y]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load i64, i64 addrspace(200)* [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = load i64, i64 addrspace(200)* [[Y]], align 8
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[TMP2]], [[TMP3]]
// CHECK-NEXT:    [[CONV:%.*]] = trunc i64 [[ADD]] to i32
// CHECK-NEXT:    ret i32 [[CONV]]
//
int builtin_annotation(long x) {
  long y = __builtin_annotation(x, "annotation_a");
  return x + y;
}

// Should be overloaded and args in AS200
// CHECK: declare i64 @llvm.annotation.i64.p200i8(i64, i8 addrspace(200)*, i8 addrspace(200)*, i32) addrspace(200)
