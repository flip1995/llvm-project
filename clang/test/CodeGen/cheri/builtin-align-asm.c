// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// REQUIRES: mips-registered-target
// RUN: %cheri_purecap_cc1 -DTEST_CAP -Wno-tautological-compare -o - -O2 -emit-llvm %s | FileCheck %s
// RUN: %cheri_purecap_cc1 -DTEST_CAP -Wno-tautological-compare -o - -O2 -S %s -mllvm -debug | FileCheck %s -check-prefix ASM

// CHECK-LABEL: define {{[^@]+}}@is_aligned
// CHECK-SAME: (i8 addrspace(200)* [[PTR:%.*]], i64 signext [[ALIGN:%.*]]) local_unnamed_addr addrspace(200) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[MASK:%.*]] = add i64 [[ALIGN]], -1
// CHECK-NEXT:    [[PTRADDR:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[PTR]])
// CHECK-NEXT:    [[SET_BITS:%.*]] = and i64 [[PTRADDR]], [[MASK]]
// CHECK-NEXT:    [[IS_ALIGNED:%.*]] = icmp eq i64 [[SET_BITS]], 0
// CHECK-NEXT:    ret i1 [[IS_ALIGNED]]
//
_Bool is_aligned(void *__capability ptr, long align) {
  // ASM-LABEL: is_aligned:
  // ASM:      daddiu	$1, $4, -1
  // ASM-NEXT: cgetandaddr	$1, $c3, $1
  // ASM-NEXT: cjr	$c17
  // ASM-NEXT: sltiu	$2, $1, 1
  return __builtin_is_aligned(ptr, align);
}

// CHECK-LABEL: define {{[^@]+}}@align_up
// CHECK-SAME: (i8 addrspace(200)* [[PTR:%.*]], i64 signext [[ALIGN:%.*]]) local_unnamed_addr addrspace(200) #2
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[MASK:%.*]] = add i64 [[ALIGN]], -1
// CHECK-NEXT:    [[PTRADDR:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[PTR]])
// CHECK-NEXT:    [[OVER_BOUNDARY:%.*]] = add i64 [[PTRADDR]], [[MASK]]
// CHECK-NEXT:    [[INVERTED_MASK:%.*]] = sub i64 0, [[ALIGN]]
// CHECK-NEXT:    [[ALIGNED_INTPTR:%.*]] = and i64 [[OVER_BOUNDARY]], [[INVERTED_MASK]]
// CHECK-NEXT:    [[DIFF:%.*]] = sub i64 [[ALIGNED_INTPTR]], [[PTRADDR]]
// CHECK-NEXT:    [[ALIGNED_RESULT:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[PTR]], i64 [[DIFF]]
// CHECK-NEXT:    [[PTRINT:%.*]] = ptrtoint i8 addrspace(200)* [[ALIGNED_RESULT]] to i64
// CHECK-NEXT:    [[MASKEDPTR:%.*]] = and i64 [[MASK]], [[PTRINT]]
// CHECK-NEXT:    [[MASKCOND:%.*]] = icmp eq i64 [[MASKEDPTR]], 0
// CHECK-NEXT:    tail call void @llvm.assume(i1 [[MASKCOND]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[ALIGNED_RESULT]]
//
void *__capability align_up(void *__capability ptr, long align) {
  // ASM-LABEL: align_up:
  // ASM:      cgetaddr	$1, $c3
  // ASM-NEXT: daddu	$1, $4, $1
  // ASM-NEXT: daddiu	$1, $1, -1
  // ASM-NEXT: dnegu	$2, $4
  // ASM-NEXT: and	$1, $1, $2
  // ASM-NEXT: cjr	$c17
  // ASM-NEXT: csetaddr	$c3, $c3, $1
  return __builtin_align_up(ptr, align);
}

// CHECK-LABEL: define {{[^@]+}}@align_down
// CHECK-SAME: (i8 addrspace(200)* [[PTR:%.*]], i64 signext [[ALIGN:%.*]]) local_unnamed_addr addrspace(200) #2
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[MASK:%.*]] = add i64 [[ALIGN]], -1
// CHECK-NEXT:    [[PTRADDR:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[PTR]])
// CHECK-NEXT:    [[TMP0:%.*]] = and i64 [[PTRADDR]], [[MASK]]
// CHECK-NEXT:    [[DIFF:%.*]] = sub i64 0, [[TMP0]]
// CHECK-NEXT:    [[ALIGNED_RESULT:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[PTR]], i64 [[DIFF]]
// CHECK-NEXT:    [[PTRINT:%.*]] = ptrtoint i8 addrspace(200)* [[ALIGNED_RESULT]] to i64
// CHECK-NEXT:    [[MASKEDPTR:%.*]] = and i64 [[MASK]], [[PTRINT]]
// CHECK-NEXT:    [[MASKCOND:%.*]] = icmp eq i64 [[MASKEDPTR]], 0
// CHECK-NEXT:    tail call void @llvm.assume(i1 [[MASKCOND]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[ALIGNED_RESULT]]
//
void *__capability align_down(void *__capability ptr, long align) {
  // ASM-LABEL: align_down:
  // ASM:      dnegu	$1, $4
  // ASM-NEXT: cjr	$c17
  // ASM-NEXT: candaddr	$c3, $c3, $1
  return __builtin_align_down(ptr, align);
}
