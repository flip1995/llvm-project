// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// We pipe through opt -mem2reg to make the test checks shorter (but keep -O0 to avoid seeing any instcombine folds)
// RUN: %cheri_cc1 -Wno-error=cheri-capability-misuse -verify -emit-llvm -o - -disable-O0-optnone %s | opt -S -mem2reg -o - | FileCheck %s
// RUN: %cheri_cc1 -Wno-cheri-capability-misuse -ast-dump %s | FileCheck %s --check-prefix=AST
// TODO: could split this into a Sema+CodeGen test, but having both here is easier

/// char* __capability -> non-cap
// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_long
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i8 addrspace(200)* @llvm.cheri.ddc.get()
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.to.pointer.i64(i8 addrspace(200)* [[TMP0]], i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    ret i64 [[TMP1]]
//
long test_capptr_to_long(char *__capability cap) {
  return (long)cap; // expected-warning{{will result in a CToPtr operation}} // expected-note{{to get the virtual address use}}
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_long
  // AST:       CStyleCastExpr {{.+}} 'long' <PointerToIntegral>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_ptr_default
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[CAP]] to i8*
// CHECK-NEXT:    ret i8* [[TMP0]]
//
char *test_capptr_to_ptr_default(char *__capability cap) {
  return (char *)cap; // expected-warning{{cast from capability type 'char * __capability' to non-capability type 'char *' is most likely an error}}
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_ptr_default
  // AST:       CStyleCastExpr {{.+}} 'char *' <CHERICapabilityToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_ptr_fromcap
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[CAP]] to i8*
// CHECK-NEXT:    ret i8* [[TMP0]]
//
char *test_capptr_to_ptr_fromcap(char *__capability cap) {
  return (__cheri_fromcap char *)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_ptr_fromcap
  // AST:       CStyleCastExpr {{.+}} 'char *' <CHERICapabilityToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_ptr_addr
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    [[TMP1:%.*]] = inttoptr i64 [[TMP0]] to i8*
// CHECK-NEXT:    ret i8* [[TMP1]]
//
char *test_capptr_to_ptr_addr(char *__capability cap) {
  return (char *)(__cheri_addr long)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_ptr_addr
  // AST:       CStyleCastExpr {{.+}} 'char *' <IntegralToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'long' <CHERICapabilityToAddress>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

/// intcap_t -> non-cap
// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_long
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    ret i64 [[TMP0]]
//
long test_intcap_to_long(__intcap_t cap) {
  return (long)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_long
  // AST:       CStyleCastExpr {{.+}} 'long' <IntegralCast>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap_t':'__intcap_t' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_long_implicit
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    ret i64 [[TMP0]]
//
long test_intcap_to_long_implicit(__intcap_t cap) {
  return cap;
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_long_implicit
  // AST:       ImplicitCastExpr {{.+}} 'long' <IntegralCast>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap_t':'__intcap_t' <LValueToRValue>
}

// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_ptr
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i8 addrspace(200)* @llvm.cheri.ddc.get()
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.to.pointer.i64(i8 addrspace(200)* [[TMP0]], i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to i8*
// CHECK-NEXT:    ret i8* [[TMP2]]
//
char *test_intcap_to_ptr(__intcap_t cap) {
  return (char *)cap; // expected-warning{{will result in a CToPtr operation}} // expected-note{{to get the virtual address use}}
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_ptr
  // AST:       CStyleCastExpr {{.+}} 'char *' <IntegralToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap_t':'__intcap_t' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_ptr_fromcap
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[CAP]] to i8*
// CHECK-NEXT:    ret i8* [[TMP0]]
//
char *test_intcap_to_ptr_fromcap(__intcap_t cap) {
  return (__cheri_fromcap void *)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_ptr_fromcap
  // AST:       ImplicitCastExpr {{.+}} 'char *' <BitCast>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'void *' <CHERICapabilityToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap_t':'__intcap_t' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_ptr_addr
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    [[TMP1:%.*]] = inttoptr i64 [[TMP0]] to i8*
// CHECK-NEXT:    ret i8* [[TMP1]]
//
char *test_intcap_to_ptr_addr(__intcap_t cap) {
  return (char *)(__cheri_addr long)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_ptr_addr
  // AST:       CStyleCastExpr {{.+}} 'char *' <IntegralToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'long' <CHERICapabilityToAddress>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap_t':'__intcap_t' <LValueToRValue> part_of_explicit_cast
}

/// char* __capability -> non-cap with intermediate cast to __intcap_t
// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_long_via_intcap
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    ret i64 [[TMP0]]
//
long test_capptr_to_long_via_intcap(char *__capability cap) {
  return (long)(__intcap_t)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_long_via_intcap
  // AST:       CStyleCastExpr {{.+}} 'long' <IntegralCast>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap_t':'__intcap_t' <PointerToIntegral>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_long_via_intcap_implicit
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    ret i64 [[TMP0]]
//
long test_capptr_to_long_via_intcap_implicit(char *__capability cap) {
  return (__intcap_t)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_long_via_intcap_implicit
  // AST:       ImplicitCastExpr {{.+}} 'long' <IntegralCast>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap_t':'__intcap_t' <PointerToIntegral>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_ptr_via_intcap_default
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i8 addrspace(200)* @llvm.cheri.ddc.get()
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.to.pointer.i64(i8 addrspace(200)* [[TMP0]], i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to i8*
// CHECK-NEXT:    ret i8* [[TMP2]]
//
char *test_capptr_to_ptr_via_intcap_default(char *__capability cap) {
  return (char *)(__intcap_t)cap; // expected-warning{{will result in a CToPtr operation}} // expected-note{{to get the virtual address use}}
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_ptr_via_intcap_default
  // AST:       CStyleCastExpr {{.+}} 'char *' <IntegralToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap_t':'__intcap_t' <PointerToIntegral>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_ptr_via_intcap_fromcap
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[CAP]] to i8*
// CHECK-NEXT:    ret i8* [[TMP0]]
//
char *test_capptr_to_ptr_via_intcap_fromcap(char *__capability cap) {
  return (__cheri_fromcap char *)(__intcap_t)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_ptr_via_intcap_fromcap
  // AST:       CStyleCastExpr {{.+}} 'char *' <CHERICapabilityToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap_t':'__intcap_t' <PointerToIntegral>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_ptr_via_intcap_addr
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    [[TMP1:%.*]] = inttoptr i64 [[TMP0]] to i8*
// CHECK-NEXT:    ret i8* [[TMP1]]
//
char *test_capptr_to_ptr_via_intcap_addr(char *__capability cap) {
  return (char *)(__cheri_addr long)(__intcap_t)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_ptr_via_intcap_addr
  // AST:       CStyleCastExpr {{.+}} 'char *' <IntegralToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'long' <CHERICapabilityToAddress>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap_t':'__intcap_t' <PointerToIntegral>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

/// intcap_t -> non-cap with intermediate cast to void* __capability
// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_long_via_capptr
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i8 addrspace(200)* @llvm.cheri.ddc.get()
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.to.pointer.i64(i8 addrspace(200)* [[TMP0]], i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    ret i64 [[TMP1]]
//
long test_intcap_to_long_via_capptr(__intcap_t cap) {
  return (long)(void *__capability)cap; // expected-warning{{will result in a CToPtr operation}} // expected-note{{to get the virtual address use}}
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_long_via_capptr
  // AST:       CStyleCastExpr {{.+}} 'long' <PointerToIntegral>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'void * __capability' <IntegralToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap_t':'__intcap_t' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_ptr_via_capptr
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[CAP]] to i8*
// CHECK-NEXT:    ret i8* [[TMP0]]
//
char *test_intcap_to_ptr_via_capptr(__intcap_t cap) {
  return (char *)(void *__capability)cap; // expected-warning{{cast from capability type 'void * __capability' to non-capability type 'char *' is most likely an error}}
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_ptr_via_capptr
  // AST:       CStyleCastExpr {{.+}} 'char *' <CHERICapabilityToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'void * __capability' <IntegralToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap_t':'__intcap_t' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_ptr_via_capptr_fromcap
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[CAP]] to i8*
// CHECK-NEXT:    ret i8* [[TMP0]]
//
char *test_intcap_to_ptr_via_capptr_fromcap(__intcap_t cap) {
  return (__cheri_fromcap void *)(void *__capability)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_ptr_via_capptr_fromcap
  // AST:       ImplicitCastExpr {{.+}} 'char *' <BitCast>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'void *' <CHERICapabilityToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'void * __capability' <IntegralToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap_t':'__intcap_t' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_ptr_via_capptr_addr
// CHECK-SAME: (i8 addrspace(200)* [[CAP:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    [[TMP1:%.*]] = inttoptr i64 [[TMP0]] to i8*
// CHECK-NEXT:    ret i8* [[TMP1]]
//
char *test_intcap_to_ptr_via_capptr_addr(__intcap_t cap) {
  return (char *)(__cheri_addr long)(void *__capability)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_ptr_via_capptr_addr
  // AST:       CStyleCastExpr {{.+}} 'char *' <IntegralToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'long' <CHERICapabilityToAddress>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'void * __capability' <IntegralToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap_t':'__intcap_t' <LValueToRValue> part_of_explicit_cast
}
