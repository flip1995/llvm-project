// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_purecap_cc1 -cheri-bounds=everywhere-unsafe -O0 -emit-llvm %s -o /dev/null \
// RUN:    -w -mllvm -debug-only="cheri-bounds" -mllvm -stats 2>&1 | FileCheck %s -check-prefix DBG
// DBG: 1 cheri-bounds     - Number of & operators checked for tightening bounds
// DBG: 7 cheri-bounds     - Number of [] operators checked for tightening bounds
// DBG: 1 cheri-bounds     - Number of [] operators where bounds were tightend
// RUN: %cheri_purecap_cc1 -cheri-bounds=everywhere-unsafe -O2 -emit-llvm %s -o - \
// RUN:   -Wcheri-subobject-bounds -Rcheri-subobject-bounds -verify | FileCheck %s
// REQUIRES: asserts

void use_buf(void *);

typedef struct {
  long x;
  int buf[10];
  char c;
} struct_with_array;

// NOTE: bounds must be set before the GEP:
// CHECK-LABEL: @test_struct_with_array1(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[BUF:%.*]] = getelementptr inbounds [[STRUCT_STRUCT_WITH_ARRAY:%.*]], [[STRUCT_STRUCT_WITH_ARRAY]] addrspace(200)* [[S:%.*]], i64 0, i32 1
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [10 x i32] addrspace(200)* [[BUF]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 40)
// CHECK-NEXT:    [[SUBSCRIPT_WITH_BOUNDS:%.*]] = bitcast i8 addrspace(200)* [[TMP1]] to [10 x i32] addrspace(200)*
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i32], [10 x i32] addrspace(200)* [[SUBSCRIPT_WITH_BOUNDS]], i64 0, i64 [[INDEX:%.*]]
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, i32 addrspace(200)* [[ARRAYIDX]], align 4, !tbaa !2
// CHECK-NEXT:    ret i32 [[TMP2]]
//
int test_struct_with_array1(struct_with_array *s, long index) {
  // should set bounds to 10
  return s->buf[index]; // expected-remark{{setting sub-object bounds for field 'buf' (array subscript on 'int [10]') to 40 bytes}}
}

// CHECK-LABEL: @test_struct_with_array2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [[STRUCT_STRUCT_WITH_ARRAY:%.*]], [[STRUCT_STRUCT_WITH_ARRAY]] addrspace(200)* [[S:%.*]], i64 [[INDEX:%.*]]
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [[STRUCT_STRUCT_WITH_ARRAY]] addrspace(200)* [[AGG_RESULT:%.*]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast [[STRUCT_STRUCT_WITH_ARRAY]] addrspace(200)* [[ARRAYIDX]] to i8 addrspace(200)*
// CHECK-NEXT:    tail call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 8 [[TMP0]], i8 addrspace(200)* align 8 [[TMP1]], i64 56, i1 false), !tbaa.struct !6
// CHECK-NEXT:    ret void
//
struct_with_array test_struct_with_array2(struct_with_array *s, long index) {
  // can't set bounds here, have to trust the caller's bounds
  return s[index]; // expected-remark{{not setting bounds for array subscript on 'struct_with_array * __capability' (array subscript on non-array type)}}
}

typedef struct {
  long x;
  int *buf;
  char c;
} struct_with_ptr;

// CHECK-LABEL: @test_struct_with_ptr1(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[BUF:%.*]] = getelementptr inbounds [[STRUCT_STRUCT_WITH_PTR:%.*]], [[STRUCT_STRUCT_WITH_PTR]] addrspace(200)* [[S:%.*]], i64 0, i32 1
// CHECK-NEXT:    [[TMP0:%.*]] = load i32 addrspace(200)*, i32 addrspace(200)* addrspace(200)* [[BUF]], align 16, !tbaa !10
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, i32 addrspace(200)* [[TMP0]], i64 [[INDEX:%.*]]
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32 addrspace(200)* [[ARRAYIDX]], align 4, !tbaa !2
// CHECK-NEXT:    ret i32 [[TMP1]]
//
int test_struct_with_ptr1(struct_with_ptr *s, long index) {
  return s->buf[index]; // expected-remark{{not setting bounds for array subscript on 'int * __capability' (array subscript on non-array type)}}
}

// CHECK-LABEL: @test_struct_with_ptr2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [[STRUCT_STRUCT_WITH_PTR:%.*]], [[STRUCT_STRUCT_WITH_PTR]] addrspace(200)* [[S:%.*]], i64 [[INDEX:%.*]]
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [[STRUCT_STRUCT_WITH_PTR]] addrspace(200)* [[AGG_RESULT:%.*]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast [[STRUCT_STRUCT_WITH_PTR]] addrspace(200)* [[ARRAYIDX]] to i8 addrspace(200)*
// CHECK-NEXT:    tail call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 16 [[TMP0]], i8 addrspace(200)* align 16 [[TMP1]], i64 48, i1 false), !tbaa.struct !13
// CHECK-NEXT:    ret void
//
struct_with_ptr test_struct_with_ptr2(struct_with_ptr *s, long index) {
  return s[index]; // expected-remark{{not setting bounds for array subscript on 'struct_with_ptr * __capability' (array subscript on non-array type)}}
}

typedef struct {
  int x;
  char buf[];
} struct_vla;
// CHECK-LABEL: @test_vla_a(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [[STRUCT_STRUCT_VLA:%.*]], [[STRUCT_STRUCT_VLA]] addrspace(200)* [[S:%.*]], i64 0, i32 1, i64 [[INDEX:%.*]]
// CHECK-NEXT:    store i8 65, i8 addrspace(200)* [[ARRAYIDX]], align 1, !tbaa !9
// CHECK-NEXT:    ret i32 0
//
int test_vla_a(struct_vla *s, long index) {
  // can't set bounds here, have to trust the caller's bounds
  s->buf[index] = 'A'; // expected-remark{{not setting bounds for array subscript on 'char []' (incomplete type)}}
  return 0;
}
// CHECK-LABEL: @test_vla_b(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_STRUCT_VLA:%.*]], align 4, addrspace(200)
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [[STRUCT_STRUCT_VLA]], [[STRUCT_STRUCT_VLA]] addrspace(200)* [[RETVAL]], i64 0, i32 1, i64 [[INDEX:%.*]]
// CHECK-NEXT:    store i8 65, i8 addrspace(200)* [[ARRAYIDX]], align 1, !tbaa !9
// CHECK-NEXT:    [[DOTFCA_0_GEP:%.*]] = getelementptr inbounds [[STRUCT_STRUCT_VLA]], [[STRUCT_STRUCT_VLA]] addrspace(200)* [[RETVAL]], i64 0, i32 0
// CHECK-NEXT:    [[DOTFCA_0_LOAD:%.*]] = load i32, i32 addrspace(200)* [[DOTFCA_0_GEP]], align 4
// CHECK-NEXT:    [[DOTFCA_0_INSERT:%.*]] = insertvalue { i32 } undef, i32 [[DOTFCA_0_LOAD]], 0
// CHECK-NEXT:    ret { i32 } [[DOTFCA_0_INSERT]]
//
struct_vla test_vla_b(long index) {
  struct_vla s2;
  s2.buf[index] = 'A'; // expected-remark{{not setting bounds for array subscript on 'char []' (incomplete type)}}
  return s2;           // prevent s2 from being optimzed out
}

// CHECK-LABEL: @test_vla_c(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = zext i32 [[LEN:%.*]] to i64
// CHECK-NEXT:    [[VLA:%.*]] = alloca i32, i64 [[TMP0]], align 4, addrspace(200)
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast i32 addrspace(200)* [[VLA]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @use_buf(i8 addrspace(200)* nonnull [[TMP1]]) #8
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, i32 addrspace(200)* [[VLA]], i64 [[INDEX:%.*]]
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, i32 addrspace(200)* [[ARRAYIDX]], align 4, !tbaa !2
// CHECK-NEXT:    ret i32 [[TMP2]]
//
int test_vla_c(int len, long index) {
  int buf[len];
  use_buf(&buf); // expected-remark{{not setting bounds for pointer to 'int [len]' (variable length array type)}}
  return buf[index]; // expected-remark{{not setting bounds for array subscript on 'int [len]' (array subscript on variable size type)}}
}

