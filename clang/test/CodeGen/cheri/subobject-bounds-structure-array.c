// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_purecap_cc1 -cheri-bounds=subobject-safe -O2 -emit-llvm %s -o - -Wcheri-subobject-bounds -Rcheri-subobject-bounds -mllvm -debug-only="cheri-bounds" -verify
// | %cheri_FileCheck %s
// RUNs: %cheri_purecap_cc1 -cheri-bounds=subobject-safe  -O0 -emit-llvm %s -o /dev/null \
// RUNs:    -w -mllvm -debug-only="cheri-bounds" -mllvm -stats 2>&1 | FileCheck %s -check-prefix DBG
// DBG:  3 cheri-bounds     - Number of & operators checked for tightening bounds
// DBG: 36 cheri-bounds     - Number of [] operators checked for tightening bounds
// DBG:  2 cheri-bounds     - Number of & operators where bounds were tightened
// DBG: 22 cheri-bounds     - Number of [] operators where bounds were tightened
// REQUIRES: asserts

void use_buf(void *);

typedef struct {
  long x;
  int buf[10];
  char c;
} struct_with_array;

// NOTE: bounds must be set before the GEP:
int test_struct_with_array1(struct_with_array *s, long index) {
  // should set bounds to 10
  return s->buf[index]; // expected-remark{{setting sub-object bounds for field 'buf' (array subscript on 'int [10]') to 40 bytes}}
}

struct_with_array test_struct_with_array2(struct_with_array *s, long index) {
  // can't set bounds here, have to trust the caller's bounds
  return s[index]; // expected-remark{{not setting bounds for array subscript on 'struct_with_array * __capability' (array subscript on non-array type)}}
}

typedef struct {
  long x;
  int *buf;
  char c;
} struct_with_ptr;

int test_struct_with_ptr1(struct_with_ptr *s, long index) {
  return s->buf[index]; // expected-remark{{not setting bounds for array subscript on 'int * __capability' (array subscript on non-array type)}}
}

struct_with_ptr test_struct_with_ptr2(struct_with_ptr *s, long index) {
  return s[index]; // expected-remark{{not setting bounds for array subscript on 'struct_with_ptr * __capability' (array subscript on non-array type)}}
}

typedef struct {
  int x;
  char buf[];
} struct_vla;
int test_vla_a(struct_vla *s, long index) {
  // can't set bounds here, have to trust the caller's bounds
  s->buf[index] = 'A'; // expected-remark{{not setting bounds for array subscript on 'char []' (incomplete type)}}
  return 0;
}
struct_vla test_vla_b(long index) {
  struct_vla s2;
  s2.buf[index] = 'A'; // expected-remark{{not setting bounds for array subscript on 'char []' (incomplete type)}}
  return s2;           // prevent s2 from being optimzed out
}

typedef struct {
  int x;
  char buf[0];
} struct_fake_vla1;
int test_fake_vla1(struct_fake_vla1 *s, long index) {
  // can't set bounds here, have to trust the caller's bounds
  s->buf[index] = 'A'; // expected-remark{{not setting bounds for array subscript on 'char [0]' (member is potential variable length array)}}
  return 0;
}

typedef struct {
  int x;
  char buf[1];
} struct_fake_vla2;
int test_fake_vla2(struct_fake_vla2 *s, long index) {
  // can't set bounds here, have to trust the caller's bounds
  s->buf[index] = 'A'; // expected-remark{{not setting bounds for array subscript on 'char [1]' (member is potential variable length array)}}
  return 0;
}

int test_vla_c(int len, long index) {
  int buf[len];
  use_buf(&buf); // expected-remark{{not setting bounds for pointer to 'int [len]' (variable length array type)}}
  return buf[index]; // expected-remark{{not setting bounds for array subscript on 'int [len]' (array subscript on variable size type)}}
  // expected-remark@-1{{not setting bounds for array decay on 'int [len]' (array decay on variable size type)}}
  // TODO: should avoid setting bounds for array decay inside array subscript (or just optimize away the redundant csetbounds)

}

typedef signed char v4i8 __attribute__ ((vector_size(4)));
v4i8 global_vector = {1, 2, 3, 4};
typedef int ext_vector_size_int32_8 __attribute__((ext_vector_type(8)));


// No bounds on vector indexing:
int test_vector(v4i8 v4, ext_vector_size_int32_8 v8) {
  char c = v4[3];
  int i = v8[7];
  return c + i;
}

// Even with an arbitraty index (backend should guarantee that it is never out of bounds)
int test_vector2(long index, v4i8 v4, ext_vector_size_int32_8 v8) {
  char c = v4[index];
  int i = v8[index];
  return c + i;
}

int test_ptr_to_array1(int (*array)[10], long index) {
  return (*array)[index]; // expected-remark{{setting sub-object bounds for array subscript on 'int [10]' to 40 bytes}}
}
int* test_ptr_to_array2(int (*array)[10], long index) {
  return array[index]; // expected-remark{{not setting bounds for array subscript on 'int (* __capability)[10]' (array subscript on non-array type)}}
  // expected-remark@-1{{setting sub-object bounds for array decay on 'int [10]' to 40 bytes}}
  // TODO: should avoid setting bounds for array decay inside array subscript (or just optimize away the redundant csetbounds)
}
int* test_ptr_to_array3(int (*array)[10][5], long index) {
  return (*array)[index]; // expected-remark{{setting sub-object bounds for array subscript on 'int [10][5]' to 200 bytes}}
  // expected-remark@-1{{setting sub-object bounds for array decay on 'int [5]' to 20 bytes}}
  // TODO: should avoid setting bounds for array decay inside array subscript (or just optimize away the redundant csetbounds)
}
int* test_ptr_to_array4(int (*array)[10][5], long index) {
  return array[index][index];
  // expected-remark@-1{{not setting bounds for array subscript on 'int (* __capability)[10][5]' (array subscript on non-array type)}}
  // expected-remark@-2{{setting sub-object bounds for array subscript on 'int [10][5]' to 200 bytes}}
  // expected-remark@-3{{setting sub-object bounds for array decay on 'int [5]' to 20 bytes}}
  // TODO: should avoid setting bounds for array decay inside array subscript (or just optimize away the redundant csetbounds)
}
int test_ptr_to_array5(int (*array)[10][5], long index) {
  return (*array)[index][index];
  // expected-remark@-1{{setting sub-object bounds for array subscript on 'int [10][5]' to 200 bytes}}
  // expected-remark@-2{{setting sub-object bounds for array subscript on 'int [5]' to 20 bytes}}
}

// TODO: C++ array references
// Some tests derived from BODiagsuite (but modified to handle a few more complicated cases):

// Overflow into next struct member
typedef struct {
  char buf[10];
  int int_field;
} my_struct21;

int test21a(my_struct21 *s, long index) {
  s->buf[index] = 'A';  // expected-remark{{setting sub-object bounds for field 'buf' (array subscript on 'char [10]') to 10 bytes}}
  return 0;
}
my_struct21 test21b(my_struct21 *s, long index) {
  my_struct21 s2;
  s2.buf[index] = 'A'; // expected-remark{{setting sub-object bounds for field 'buf' (array subscript on 'char [10]') to 10 bytes}}
  return s2; // prevent s2 from being optimzed out
}

int test21c(my_struct21 *s, long index) {
  // Should not set bounds on s here, but should do for buf
  s[0].buf[index] = 'A'; // expected-remark{{setting sub-object bounds for field 'buf' (array subscript on 'char [10]') to 10 bytes}}
  // expected-remark@-1{{not setting bounds for array subscript on 'my_struct21 * __capability' (array subscript on non-array type)}}
  return 0;
}

int test21d(my_struct21 *s, long index) {
  // Should not set bounds on s here, but should do for buf
  (*s).buf[index] = 'A'; // expected-remark{{setting sub-object bounds for field 'buf' (array subscript on 'char [10]') to 10 bytes}}
  return 0;
}

// Overflow into padding
typedef struct {
  int int_field;
  char buf[10];
} my_struct22;
int test22a(my_struct22 *s, long index) {
  s->buf[index] = 'A'; // expected-remark{{setting sub-object bounds for field 'buf' (array subscript on 'char [10]') to 10 bytes}}
  return 0;
}
my_struct22 test22b(long index) {
  my_struct22 s2;
  s2.buf[index] = 'A'; // expected-remark{{setting sub-object bounds for field 'buf' (array subscript on 'char [10]') to 10 bytes}}
  return s2; // prevent s2 from being optimzed out
}

// Overflow in union member
typedef union {
  char buf[10];
  long otherbuf[10];
} my_union25;

int test25a(my_union25 *u, long index) {
  u->buf[index] = 'A'; // expected-remark{{setting sub-object bounds for field 'buf' (array subscript on 'char [10]') to 10 bytes}}
  return 0;
}
my_union25 test25b(long index) {
  my_union25 u2;
  u2.buf[index] = 'A'; // expected-remark{{setting sub-object bounds for field 'buf' (array subscript on 'char [10]') to 10 bytes}}
  return u2; // prevent u2 from being optimzed out
}
int test25c(my_union25 *u, long index) {
  // Should not set bounds on u here, but should do for buf
  u[0].buf[index] = 'A'; // expected-remark{{setting sub-object bounds for field 'buf' (array subscript on 'char [10]') to 10 bytes}}
  // expected-remark@-1{{not setting bounds for array subscript on 'my_union25 * __capability' (array subscript on non-array type)}}
  return 0;
}
int test25d(my_union25 *u, long index) {
  // Should not set bounds on u here, but should do for buf
  (*u).buf[index] = 'A'; // expected-remark{{setting sub-object bounds for field 'buf' (array subscript on 'char [10]') to 10 bytes}}
  return 0;
}

// simple multidimensional array overflow
typedef struct {
  char buf1[10];
  char buf2[10];
} my_struct28;

int test28a(long index) {
  my_struct28 array2[5];
  array2[4].buf1[index] = 'A'; // expected-remark{{setting sub-object bounds for field 'buf1' (array subscript on 'char [10]') to 10 bytes}}
  // expected-remark@-1{{setting bounds for array subscript on 'my_struct28 [5]' to 100 bytes}}
  use_buf(&array2); // prevent array from being optimized away
  // expected-remark@-1{{setting bounds for pointer to 'my_struct28 [5]' to 100 bytes}}
  return 0;
}

int test28b(my_struct28 **array1, long index) {
  array1[4]->buf1[index] = 'A'; // expected-remark{{setting sub-object bounds for field 'buf1' (array subscript on 'char [10]') to 10 bytes}}
  // expected-remark@-1{{not setting bounds for array subscript on 'my_struct28 * __capability * __capability' (array subscript on non-array type)}}
  return 0;
}

int test28c(long index1, long index2) {
  my_struct28 array2[5];
  array2[index1].buf1[index2] = 'A'; // expected-remark{{setting sub-object bounds for field 'buf1' (array subscript on 'char [10]') to 10 bytes}}
  // expected-remark@-1{{setting bounds for array subscript on 'my_struct28 [5]' to 100 bytes}}
  use_buf(&array2); // prevent array from being optimized away
  // expected-remark@-1{{setting bounds for pointer to 'my_struct28 [5]' to 100 bytes}}
  return 0;
}

int test28d(my_struct28 **array1, long index1, long index2) {
  array1[index1]->buf1[index2] = 'A'; // expected-remark{{setting sub-object bounds for field 'buf1' (array subscript on 'char [10]') to 10 bytes}}
  // expected-remark@-1{{not setting bounds for array subscript on 'my_struct28 * __capability * __capability' (array subscript on non-array type)}}
  return 0;
}
