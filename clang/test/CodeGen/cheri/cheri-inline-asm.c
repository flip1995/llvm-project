// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// REQUIRES: mips-registered-target

// RUN: %cheri_purecap_cc1 -emit-llvm -o - %s | %cheri_FileCheck %s
// RUN: %cheri_purecap_cc1 -S -o - %s -verify | FileCheck %s -check-prefix ASM
// CHECK-LABEL: @f(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca i8 addrspace(200)*, align [[#CAP_SIZE]], addrspace(200)
// CHECK-NEXT:    store i8 addrspace(200)* [[P:%.*]], i8 addrspace(200)* addrspace(200)* [[P_ADDR]], align [[#CAP_SIZE]]
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[P_ADDR]], align [[#CAP_SIZE]]
// CHECK-NEXT:    call void asm sideeffect "# ASM EXPR: $0", "rm,~{memory},~{$1}"(i8 addrspace(200)* [[TMP0]]) #1, !srcloc !2
// CHECK-NEXT:    [[TMP1:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[P_ADDR]], align [[#CAP_SIZE]]
// CHECK-NEXT:    call void asm sideeffect "# ASM EXPR: $0", "r,~{memory},~{$1}"(i8 addrspace(200)* [[TMP1]]) #1, !srcloc !3
// CHECK-NEXT:    call void asm sideeffect "# ASM EXPR: $0", "*m,~{memory},~{$1}"(i8 addrspace(200)* addrspace(200)* [[P_ADDR]]) #1, !srcloc !4
// CHECK-NEXT:    ret void
//
void f(char *p) {
  asm volatile("# ASM EXPR: %0" : : "rm"(p) : "memory");
  // mem-expr:
  // ASM: # ASM EXPR: {{[0-9]+}}($c{{[0-9]+}})
  asm volatile("# ASM EXPR: %0" : : "r"(p) : "memory");
  // capabitliy register:
  // ASM: # ASM EXPR: $c{{[0-9]+}}
  asm volatile("# ASM EXPR: %0" : : "m"(p) : "memory");
  // mem-expr:
  // ASM: # ASM EXPR: {{[0-9]+}}($c{{[0-9]+}})
}


// CHECK-LABEL: @f2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[B:%.*]] = alloca i8, align 1, addrspace(200)
// CHECK-NEXT:    store i8 0, i8 addrspace(200)* [[B]], align 1
// CHECK-NEXT:    [[TMP0:%.*]] = load i8, i8 addrspace(200)* [[B]], align 1
// CHECK-NEXT:    [[TOBOOL:%.*]] = trunc i8 [[TMP0]] to i1
// CHECK-NEXT:    [[TMP1:%.*]] = call i8 asm sideeffect "", "=C,0,~{$1}"(i1 [[TOBOOL]]) #1, !srcloc !5
// CHECK-NEXT:    store i8 [[TMP1]], i8 addrspace(200)* [[B]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = load i8, i8 addrspace(200)* [[B]], align 1
// CHECK-NEXT:    [[TOBOOL1:%.*]] = trunc i8 [[TMP2]] to i1
// CHECK-NEXT:    ret i1 [[TOBOOL1]]
//
_Bool f2(void) {
  _Bool b = 0;
  asm volatile("" : "+C"(b)); // NOTE: this is invalid but is only detected when emitting asm:
  // expected-error@-1{{couldn't allocate output register for constraint 'C'}}
  return b;
}
