// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_purecap_cc1 -cheri-bounds=subobject-safe -O2 -emit-llvm %s -o - -Rcheri-subobject-bounds -mllvm -debug-only="cheri-bounds" -verify | %cheri_FileCheck %s
// RUN: %cheri_purecap_cc1 -cheri-bounds=subobject-safe -O0 -emit-llvm %s -o /dev/null -w -mllvm -stats 2>&1 | FileCheck %s -check-prefix DBG -implicit-check-not cheri-bounds
// DBG: ... Statistics Collected ...
// DBG:  9 cheri-bounds - Number of array-to-pointer-decays checked for tightening bounds
// DBG:  4 cheri-bounds - Number of array-to-pointer-decays where remaining allocation size was used
// DBG:  5 cheri-bounds - Number of array-to-pointer-decays where bounds were tightened
// REQUIRES: asserts

void overflow_buffer(void *);

typedef struct {
  long x;
  int buf[10];
  char c;
} struct_with_array;

// NOTE: bounds must be set before the GEP:
// CHECK-LABEL: @test_struct_member_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [[STRUCT_STRUCT_WITH_ARRAY:%.*]], [[STRUCT_STRUCT_WITH_ARRAY]] addrspace(200)* [[S:%.*]], i64 0, i32 1, i64 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 addrspace(200)* [[ARRAYDECAY]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 40)
// CHECK-NEXT:    tail call void @overflow_buffer(i8 addrspace(200)* [[TMP1]]) #5
// CHECK-NEXT:    ret void
//
void test_struct_member_decay(struct_with_array *s, long index) {
  // should set bounds to 10
  overflow_buffer(s->buf); // expected-remark{{setting sub-object bounds for field 'buf' (array decay on 'int [10]') to 40 bytes}}
}

// CHECK-LABEL: @test_local_array_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[BUFFER:%.*]] = alloca [12 x i32], align 4, addrspace(200)
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [12 x i32] addrspace(200)* [[BUFFER]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @llvm.lifetime.start.p200i8(i64 48, i8 addrspace(200)* nonnull [[TMP0]]) #5
// CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 48)
// CHECK-NEXT:    call void @overflow_buffer(i8 addrspace(200)* [[TMP1]]) #5
// CHECK-NEXT:    call void @llvm.lifetime.end.p200i8(i64 48, i8 addrspace(200)* nonnull [[TMP0]]) #5
// CHECK-NEXT:    ret void
//
void test_local_array_decay(struct_with_array *s, long index) {
  int buffer[12];
  // should set bounds to 10
  overflow_buffer(buffer); // expected-remark{{setting bounds for array decay on 'int [12]' to 48 bytes}}
}

// CHECK-LABEL: @return_stack_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[BUFFER:%.*]] = alloca [21 x i32], align 4, addrspace(200)
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [21 x i32] addrspace(200)* [[BUFFER]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @llvm.lifetime.start.p200i8(i64 84, i8 addrspace(200)* nonnull [[TMP0]]) #5
// CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 84)
// CHECK-NEXT:    call void @llvm.lifetime.end.p200i8(i64 84, i8 addrspace(200)* nonnull [[TMP0]]) #5
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
void* return_stack_decay(struct_with_array *s, long index) {
  int buffer[21];
  return buffer; // expected-remark{{setting bounds for array decay on 'int [21]' to 84 bytes}}
  // expected-warning@-1{{address of stack memory associated with local variable 'buffer' returned}}
}

float global_buffer[100];
// CHECK-LABEL: @test_global_array_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* bitcast ([100 x float] addrspace(200)* @global_buffer to i8 addrspace(200)*), i64 400)
// CHECK-NEXT:    tail call void @overflow_buffer(i8 addrspace(200)* [[TMP0]]) #5
// CHECK-NEXT:    ret void
//
void test_global_array_decay(long index) {
  // should set bounds to 100 * 4
  overflow_buffer(global_buffer); // expected-remark{{setting bounds for array decay on 'float [100]' to 400 bytes}}
}

struct foo {
  int buffer[1];
  char buffer2;
} global_foo;

// CHECK-LABEL: @test_global_struct_array_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* bitcast (%struct.foo addrspace(200)* @global_foo to i8 addrspace(200)*), i64 4)
// CHECK-NEXT:    tail call void @overflow_buffer(i8 addrspace(200)* [[TMP0]]) #5
// CHECK-NEXT:    ret void
//
void test_global_struct_array_decay(struct_with_array *s, long index) {
  overflow_buffer(global_foo.buffer); // expected-remark{{setting sub-object bounds for field 'buffer' (array decay on 'int [1]') to 4 bytes}}
}

// CHECK-LABEL: @test_local_vla_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VLA:%.*]] = alloca i32, i64 [[SIZE:%.*]], align 4, addrspace(200)
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 addrspace(200)* [[VLA]] to i8 addrspace(200)*
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    call void @overflow_buffer(i8 addrspace(200)* [[TMP1]]) #5
// CHECK-NEXT:    ret void
//
void test_local_vla_decay(struct_with_array *s, long size) {
  // TODO: should not set bounds here since the backend will bound the VLA
  int vla[size];
  overflow_buffer(vla); // expected-remark{{setting bounds for array decay on 'int [size]' to remaining bytes (array decay on variable size type)}}
}

struct vla_struct {
  char len;
  int vla[];
};

// CHECK-LABEL: @test_vla_struct_member_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [[STRUCT_VLA_STRUCT:%.*]], [[STRUCT_VLA_STRUCT]] addrspace(200)* [[S:%.*]], i64 0, i32 1, i64 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 addrspace(200)* [[ARRAYDECAY]] to i8 addrspace(200)*
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    tail call void @overflow_buffer(i8 addrspace(200)* [[TMP1]]) #5
// CHECK-NEXT:    ret void
//
void test_vla_struct_member_decay(struct vla_struct *s, long index) {
  overflow_buffer(s->vla); // expected-remark{{setting sub-object bounds for field 'vla' (array decay on 'int []') to remaining bytes (member is potential variable length array)}}
}

struct fake_vla_struct {
  char len;
  int fake_vla[0];
};

// CHECK-LABEL: @test_fake_vla_struct_member_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [[STRUCT_FAKE_VLA_STRUCT:%.*]], [[STRUCT_FAKE_VLA_STRUCT]] addrspace(200)* [[S:%.*]], i64 0, i32 1, i64 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 addrspace(200)* [[ARRAYDECAY]] to i8 addrspace(200)*
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    tail call void @overflow_buffer(i8 addrspace(200)* [[TMP1]]) #5
// CHECK-NEXT:    ret void
//
void test_fake_vla_struct_member_decay(struct fake_vla_struct *s, long index) {
  overflow_buffer(s->fake_vla); // expected-remark{{setting sub-object bounds for field 'fake_vla' (array decay on 'int [0]') to remaining bytes (member is potential variable length array)}}
}

struct fake_vla_struct2 {
  char len;
  int fake_vla2[1]; // last member, size==1 -> possible fake VLA
};

// CHECK-LABEL: @test_fake_vla_struct2_member_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [[STRUCT_FAKE_VLA_STRUCT2:%.*]], [[STRUCT_FAKE_VLA_STRUCT2]] addrspace(200)* [[S:%.*]], i64 0, i32 1, i64 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 addrspace(200)* [[ARRAYDECAY]] to i8 addrspace(200)*
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    tail call void @overflow_buffer(i8 addrspace(200)* [[TMP1]]) #5
// CHECK-NEXT:    ret void
//
void test_fake_vla_struct2_member_decay(struct fake_vla_struct2 *s, long index) {
  // TODO: should set reverse bounds here: raise bottom to current offset
  overflow_buffer(s->fake_vla2); // expected-remark{{setting sub-object bounds for field 'fake_vla2' (array decay on 'int [1]') to remaining bytes (member is potential variable length array)}}
}
