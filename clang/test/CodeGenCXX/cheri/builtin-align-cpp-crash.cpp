// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_purecap_cc1 -o - -O2 -emit-llvm  %s | FileCheck %s
// Found while trying to use the builtin in QtBase
// CHECK-LABEL: @test1(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[C:%.*]])
// CHECK-NEXT:    [[POW2:%.*]] = zext i32 [[B:%.*]] to i64
// CHECK-NEXT:    [[NOTMASK:%.*]] = shl nsw i64 -1, [[POW2]]
// CHECK-NEXT:    [[TMP1:%.*]] = and i64 [[TMP0]], [[NOTMASK]]
// CHECK-NEXT:    [[TMP2:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* [[C]], i64 [[TMP1]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP2]]
//
extern "C" char* test1(char* c, int b) {
  return __builtin_p2align_down(c, b);
}

// Found while compiling libnv
// CHECK-LABEL: @test2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[VALUE:%.*]])
// CHECK-NEXT:    [[OVER_BOUNDARY:%.*]] = add i64 [[TMP0]], 3
// CHECK-NEXT:    [[TMP1:%.*]] = and i64 [[OVER_BOUNDARY]], -4
// CHECK-NEXT:    [[TMP2:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* [[VALUE]], i64 [[TMP1]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP2]]
//
extern "C" __uintcap_t test2(__uintcap_t value) {
  // There should be two casts from capability to address (one for size, one for
  // alignment). The alignment one could be an offset get instead but this doesn't
  // really make any difference since Sema validates that it is a valid capability.
  return __builtin_align_up(value, (__uintcap_t)sizeof(0));
}
