; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --check-globals --include-generated-funcs
; RUN: opt -S -passes=globalopt < %s | FileCheck %s "--implicit-check-not=@bitcast"
; Test case reduced from compiling libc++ directory_iterator.cpp for hybrid CHERI:
; Assertion failed: (C->getType()->getIntegerBitWidth() <= 64)
; Check that we don't attempt to optimize stores of non-zero i128s to capabilities (but it is valid for plain pointers)
; After globalopt only the @bitcast_nonzero_i128_to_cap function should remain.
target datalayout = "eme-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n64-S128"

define internal void @bitcast_zero_i128_to_cap() {
entry:
  %alloca = alloca i128, align 16
  store i128 0, i128* %alloca, align 16
  %0 = bitcast i128* %alloca to i8 addrspace(200)**
  %1 = load i8 addrspace(200)*, i8 addrspace(200)** %0, align 16
  store i8 addrspace(200)* %1, i8 addrspace(200)** @cap_from_zero, align 16
  ret void
}

define internal void @bitcast_nonzero_i128_to_cap() {
entry:
  %alloca = alloca i128, align 16
  store i128 4321, i128* %alloca, align 16
  %0 = bitcast i128* %alloca to i8 addrspace(200)**
  %1 = load i8 addrspace(200)*, i8 addrspace(200)** %0, align 16
  store i8 addrspace(200)* %1, i8 addrspace(200)** @cap_from_nonzero, align 16
  ret void
}

define internal void @bitcast_zero_i64_to_ptr() {
entry:
  %alloca = alloca i64, align 8
  store i64 0, i64* %alloca, align 8
  %0 = bitcast i64* %alloca to i8**
  %1 = load i8*, i8** %0, align 8
  store i8* %1, i8** @ptr_from_zero, align 8
  ret void
}

define internal void @bitcast_nonzero_i64_to_ptr() {
entry:
  %alloca = alloca i64, align 8
  store i64 4321, i64* %alloca, align 8
  %0 = bitcast i64* %alloca to i8**
  %1 = load i8*, i8** %0, align 8
  store i8* %1, i8** @ptr_from_nonzero, align 8
  ret void
}

@llvm.global_ctors = appending global [4 x { i32, void ()*, i8* }]
  [{ i32, void ()*, i8* } { i32 65535, void ()* @bitcast_zero_i128_to_cap, i8* null },
  { i32, void ()*, i8* } { i32 65535, void ()* @bitcast_nonzero_i128_to_cap, i8* null },
  { i32, void ()*, i8* } { i32 65535, void ()* @bitcast_zero_i64_to_ptr, i8* null },
  { i32, void ()*, i8* } { i32 65535, void ()* @bitcast_nonzero_i64_to_ptr, i8* null }]

@cap_from_zero = dso_local global i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i32 1234)
@cap_from_nonzero = dso_local global i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i32 1234)
@ptr_from_zero = dso_local global i8* getelementptr (i8, i8* null, i32 1234)
@ptr_from_nonzero = dso_local global i8* getelementptr (i8, i8* null, i32 1234)

;.
; CHECK: @[[LLVM_GLOBAL_CTORS:[a-zA-Z0-9_$"\\.-]+]] = appending global [1 x { i32, void ()*, i8* }] [{ i32, void ()*, i8* } { i32 65535, void ()* @bitcast_nonzero_i128_to_cap, i8* null }]
; CHECK: @[[CAP_FROM_ZERO:[a-zA-Z0-9_$"\\.-]+]] = dso_local local_unnamed_addr global i8 addrspace(200)* null
; CHECK: @[[CAP_FROM_NONZERO:[a-zA-Z0-9_$"\\.-]+]] = dso_local local_unnamed_addr global i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1234)
; CHECK: @[[PTR_FROM_ZERO:[a-zA-Z0-9_$"\\.-]+]] = dso_local local_unnamed_addr global i8* null
; CHECK: @[[PTR_FROM_NONZERO:[a-zA-Z0-9_$"\\.-]+]] = dso_local local_unnamed_addr global i8* inttoptr (i64 4321 to i8*)
;.
; CHECK-LABEL: define {{[^@]+}}@bitcast_nonzero_i128_to_cap() {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ALLOCA:%.*]] = alloca i128, align 16
; CHECK-NEXT:    store i128 4321, i128* [[ALLOCA]], align 16
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i128* [[ALLOCA]] to i8 addrspace(200)**
; CHECK-NEXT:    [[TMP1:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)** [[TMP0]], align 16
; CHECK-NEXT:    store i8 addrspace(200)* [[TMP1]], i8 addrspace(200)** @cap_from_nonzero, align 16
; CHECK-NEXT:    ret void
;
