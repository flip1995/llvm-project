; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; REQUIRES: asserts
; RUN: rm -f %t.dbg-opt %t.dbg-llc
; RUN: opt @PURECAP_HARDFLOAT_ARGS@ -cheri-bound-allocas -debug-only=cheri-bound-allocas -S -o - %s 2>%t.dbg-opt | FileCheck %s
; RUN: FileCheck %s -input-file=%t.dbg-opt -check-prefix DBG
; RUN: llc @PURECAP_HARDFLOAT_ARGS@ -debug-only=cheri-bound-allocas -o - %s 2>%t.dbg-llc | FileCheck %s -check-prefix ASM
; RUN: FileCheck %s -input-file=%t.dbg-llc -check-prefix DBG
target datalayout = "@PURECAP_DATALAYOUT@"

; created from the following C source code (when compiled with subobject bounds):
; void use(void* arg);
;
;void use_inline(int* arg) {
;  *arg = 2;
;}
;
;int stack_array() {
;  int array[10];
;  use(array);
;  return array[5];
;}
;
;int stack_int() {
;  int value = 1;
;  use(&value);
;  return value;
;}
;
;int stack_int_inlined() {
;  int value = 1;
;  use_inline(&value);
;  return value;
;}


define void @use_inline(i32 addrspace(200)* nocapture %arg) local_unnamed_addr addrspace(200) #0 {
entry:
  store i32 2, i32 addrspace(200)* %arg, align 4
  ret void
}

define signext i32 @stack_array() local_unnamed_addr addrspace(200) #1 {
entry:
  %array = alloca [10 x i32], align 4, addrspace(200)
  %0 = bitcast [10 x i32] addrspace(200)* %array to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 40, i8 addrspace(200)* nonnull %0) #6
  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.iCAPRANGE(i8 addrspace(200)* nonnull %0, iCAPRANGE 40)
  call void @use(i8 addrspace(200)* %1) #6
  %arrayidx = getelementptr inbounds i8, i8 addrspace(200)* %1, i64 20
  %2 = bitcast i8 addrspace(200)* %arrayidx to i32 addrspace(200)*
  %3 = load i32, i32 addrspace(200)* %2, align 4
  call void @llvm.lifetime.end.p200i8(i64 40, i8 addrspace(200)* nonnull %0) #6
  ret i32 %3
}

; DBG-LABEL: Checking function stack_array
; DBG-NEXT: cheri-bound-allocas:  -Checking if bitcast needs stack bounds:   %0 = bitcast [10 x i32] addrspace(200)* %array to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.end.p200i8(i64 40, i8 addrspace(200)* nonnull %0)
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for use in setbounds with smaller or equal size: original size=40, setbounds size=40 current offset=0:  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.iCAPRANGE(i8 addrspace(200)* nonnull %0, iCAPRANGE 40)
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.start.p200i8(i64 40, i8 addrspace(200)* nonnull %0)
; DBG-NEXT: cheri-bound-allocas:  -no bitcast users need bounds:   %0 = bitcast [10 x i32] addrspace(200)* %array to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas: stack_array: 0 of 1 users need bounds for   %array = alloca [10 x i32], align 4, addrspace(200)
; DBG-NEXT: cheri-bound-allocas: No need to set bounds on stack alloca  %array = alloca [10 x i32], align 4, addrspace(200)
; DBG-EMPTY:

declare void @llvm.lifetime.start.p200i8(i64 immarg, i8 addrspace(200)* nocapture) addrspace(200) #2

declare void @use(i8 addrspace(200)*) local_unnamed_addr addrspace(200) #3

declare i8 addrspace(200)* @llvm.cheri.cap.bounds.set.iCAPRANGE(i8 addrspace(200)*, iCAPRANGE) addrspace(200) #4

declare void @llvm.lifetime.end.p200i8(i64 immarg, i8 addrspace(200)* nocapture) addrspace(200) #2

define signext i32 @stack_int() local_unnamed_addr addrspace(200) #1 {
entry:
  %value = alloca i32, align 4, addrspace(200)
  %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 4, i8 addrspace(200)* nonnull %0) #6
  store i32 1, i32 addrspace(200)* %value, align 4
  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.iCAPRANGE(i8 addrspace(200)* nonnull %0, iCAPRANGE 4)
  call void @use(i8 addrspace(200)* %1) #6
  %2 = load i32, i32 addrspace(200)* %value, align 4
  call void @llvm.lifetime.end.p200i8(i64 4, i8 addrspace(200)* nonnull %0) #6
  ret i32 %2
}

; DBG-LABEL: Checking function stack_int
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   %2 = load i32, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   %2 = load i32, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   store i32 1, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   store i32 1, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -Checking if bitcast needs stack bounds:   %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.end.p200i8(i64 4, i8 addrspace(200)* nonnull %0)
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for use in setbounds with smaller or equal size: original size=4, setbounds size=4 current offset=0:  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.iCAPRANGE(i8 addrspace(200)* nonnull %0, iCAPRANGE 4)
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.start.p200i8(i64 4, i8 addrspace(200)* nonnull %0)
; DBG-NEXT: cheri-bound-allocas:  -no bitcast users need bounds:   %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas: stack_int: 0 of 3 users need bounds for   %value = alloca i32, align 4, addrspace(200)
; DBG-NEXT: cheri-bound-allocas: No need to set bounds on stack alloca  %value = alloca i32, align 4, addrspace(200)
; DBG-EMPTY:

define signext i32 @stack_int_inlined() local_unnamed_addr addrspace(200) #5 {
entry:
  %value = alloca i32, align 4, addrspace(200)
  %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 4, i8 addrspace(200)* nonnull %0) #6
  store i32 1, i32 addrspace(200)* %value, align 4
  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.iCAPRANGE(i8 addrspace(200)* nonnull %0, iCAPRANGE 4)
  %address.with.bounds = bitcast i8 addrspace(200)* %1 to i32 addrspace(200)*
  store i32 2, i32 addrspace(200)* %address.with.bounds, align 4
  %2 = load i32, i32 addrspace(200)* %value, align 4
  call void @llvm.lifetime.end.p200i8(i64 4, i8 addrspace(200)* nonnull %0) #6
  ret i32 %2
}

; DBG-LABEL: Checking function stack_int_inlined
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   %2 = load i32, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   %2 = load i32, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   store i32 1, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   store i32 1, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -Checking if bitcast needs stack bounds:   %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.end.p200i8(i64 4, i8 addrspace(200)* nonnull %0)
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for use in setbounds with smaller or equal size: original size=4, setbounds size=4 current offset=0:  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.iCAPRANGE(i8 addrspace(200)* nonnull %0, iCAPRANGE 4)
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.start.p200i8(i64 4, i8 addrspace(200)* nonnull %0)
; DBG-NEXT: cheri-bound-allocas:  -no bitcast users need bounds:   %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas: stack_int_inlined: 0 of 3 users need bounds for   %value = alloca i32, align 4, addrspace(200)
; DBG-NEXT: cheri-bound-allocas: No need to set bounds on stack alloca  %value = alloca i32, align 4, addrspace(200)
; DBG-EMPTY:

define signext i32 @out_of_bounds_setbounds() local_unnamed_addr addrspace(200) #5 {
entry:
  %value = alloca i32, align 4, addrspace(200)
  ; TOO big, cannot elide the setbonds:
  %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.iCAPRANGE(i8 addrspace(200)* nonnull %0, iCAPRANGE 5)
  %address.with.bounds = bitcast i8 addrspace(200)* %1 to i32 addrspace(200)*
  store i32 2, i32 addrspace(200)* %address.with.bounds, align 4
  %2 = load i32, i32 addrspace(200)* %value, align 4
  ret i32 %2
}

; DBG-NEXT: Checking function out_of_bounds_setbounds
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   %2 = load i32, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   %2 = load i32, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -Checking if bitcast needs stack bounds:   %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas:   -out_of_bounds_setbounds: setbounds use offset OUT OF BOUNDS and will trap -> adding csetbounds:   %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.iCAPRANGE(i8 addrspace(200)* nonnull %0, iCAPRANGE 5)
; DBG-NEXT: cheri-bound-allocas:  -Adding stack bounds since bitcast user needs bounds:   %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.iCAPRANGE(i8 addrspace(200)* nonnull %0, iCAPRANGE 5)
; DBG-NEXT: cheri-bound-allocas: Found alloca use that needs bounds:   %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas: out_of_bounds_setbounds: 1 of 2 users need bounds for   %value = alloca i32, align 4, addrspace(200)
; DBG-NEXT: out_of_bounds_setbounds: setting bounds on stack alloca to 4  %value = alloca i32, align 4, addrspace(200)
; DBG-EMPTY:

define signext i32 @setbounds_escapes() local_unnamed_addr addrspace(200) #5 {
entry:
  %value = alloca i32, align 4, addrspace(200)
  ; Too big, cannot elide the setbonds:
  %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.iCAPRANGE(i8 addrspace(200)* nonnull %0, iCAPRANGE 4)
  %address.with.bounds = bitcast i8 addrspace(200)* %1 to i32 addrspace(200)*
  store i32 2, i32 addrspace(200)* %address.with.bounds, align 4
  call void @use(i8 addrspace(200)* %1)
  %2 = load i32, i32 addrspace(200)* %value, align 4
  ret i32 %2
}

; DBG-NEXT: Checking function setbounds_escapes
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   %2 = load i32, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   %2 = load i32, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -Checking if bitcast needs stack bounds:   %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for use in setbounds with smaller or equal size: original size=4, setbounds size=4 current offset=0:  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.iCAPRANGE(i8 addrspace(200)* nonnull %0, iCAPRANGE 4)
; DBG-NEXT: cheri-bound-allocas:  -no bitcast users need bounds:   %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas: setbounds_escapes: 0 of 2 users need bounds for   %value = alloca i32, align 4, addrspace(200)
; DBG-NEXT: cheri-bound-allocas: No need to set bounds on stack alloca  %value = alloca i32, align 4, addrspace(200)
; DBG-EMPTY:

; llvm.assume() should not add bounds:
define void @assume_aligned() local_unnamed_addr addrspace(200) nounwind {
entry:
  %0 = alloca [4 x i8], align 4, addrspace(200)
  call void @llvm.assume(i1 true) [ "align"([4 x i8] addrspace(200)* %0, i64 4) ]
  %1 = bitcast [4 x i8] addrspace(200)* %0 to i32 addrspace(200)*
  store i32 1, i32 addrspace(200)* %1
  ret void
}

; DBG-NEXT: Checking function assume_aligned
; DBG-NEXT: cheri-bound-allocas:  -Checking if bitcast needs stack bounds:   %1 = bitcast [4 x i8] addrspace(200)* %0 to i32 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas:   -Checking if load/store needs bounds (GEP offset is 0):   store i32 1, i32 addrspace(200)* %1, align 4
; DBG-NEXT: cheri-bound-allocas:    -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:    -Load/store is in bounds -> can reuse $csp for   store i32 1, i32 addrspace(200)* %1, align 4
; DBG-NEXT: cheri-bound-allocas:  -no bitcast users need bounds:   %1 = bitcast [4 x i8] addrspace(200)* %0 to i32 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas:  -No need for stack bounds for assume:   call void @llvm.assume(i1 true) [ "align"([4 x i8] addrspace(200)* %0, i64 4) ]
; DBG-NEXT: cheri-bound-allocas: assume_aligned: 0 of 2 users need bounds for   %0 = alloca [4 x i8], align 4, addrspace(200)
; DBG-NEXT: cheri-bound-allocas: No need to set bounds on stack alloca  %0 = alloca [4 x i8], align 4, addrspace(200)
; DBG-EMPTY:

declare void @llvm.assume(i1) addrspace(200) #1

attributes #0 = { norecurse nounwind writeonly }
attributes #1 = { nounwind }
attributes #2 = { argmemonly nounwind }
attributes #3 = { nounwind }
attributes #4 = { nounwind readnone }
attributes #5 = { nounwind writeonly }
attributes #6 = { nounwind }

