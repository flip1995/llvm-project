; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --force-update
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/cheri-pointer-comparison-unsigned.ll
; RUN: llc -mtriple=riscv32 --relocation-model=pic -target-abi ilp32f -mattr=+xcheri,+f %s -o - | FileCheck %s --check-prefix=HYBRID
; RUN: llc -mtriple=riscv32 --relocation-model=pic -target-abi il32pc64f -mattr=+xcheri,+cap-mode,+f %s -o - | FileCheck %s --check-prefix=PURECAP
; Check that selects and branches using capability compares use unsigned comparisons.
; NGINX has a loop with (void*)-1 as a sentinel value which was never entered due to this bug.
; Original issue: https://github.com/CTSRD-CHERI/llvm/issues/199
; Fixed upstream in https://reviews.llvm.org/D70917 (be15dfa88fb1ed94d12f374797f98ede6808f809)
;
; Original source code showing this surprising behaviour (for CHERI-MIPS):
; int
; main(void)
; {
;         void *a, *b;
;
;         a = (void *)0x12033091e;
;         b = (void *)0xffffffffffffffff;
;
;         if (a < b) {
;                 printf("ok\n");
;                 return (0);
;         }
;
;         printf("surprising result\n");
;         return (1);
; }
;
; Morello had a similar code generation issue for selects, where a less than
; generated a csel instruction using a singed predicate instead of the unsigned one:
; void *select_lt(void *p1, void *p2) {
;   return p1 < p2 ? p1 : p2;
; }
; See https://git.morello-project.org/morello/llvm-project/-/issues/22


define i32 @lt(i8 addrspace(200)* %a, i8 addrspace(200)* %b) nounwind {
; HYBRID-LABEL: lt:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    sltu a0, a0, a1
; HYBRID-NEXT:    ret
;
; PURECAP-LABEL: lt:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    sltu a0, a0, a1
; PURECAP-NEXT:    cret
entry:
  %cmp = icmp ult i8 addrspace(200)* %a, %b
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @le(i8 addrspace(200)* %a, i8 addrspace(200)* %b) nounwind {
; HYBRID-LABEL: le:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    sltu a0, a1, a0
; HYBRID-NEXT:    xori a0, a0, 1
; HYBRID-NEXT:    ret
;
; PURECAP-LABEL: le:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    sltu a0, a1, a0
; PURECAP-NEXT:    xori a0, a0, 1
; PURECAP-NEXT:    cret
entry:
  %cmp = icmp ule i8 addrspace(200)* %a, %b
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @gt(i8 addrspace(200)* %a, i8 addrspace(200)* %b) nounwind {
; HYBRID-LABEL: gt:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    sltu a0, a1, a0
; HYBRID-NEXT:    ret
;
; PURECAP-LABEL: gt:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    sltu a0, a1, a0
; PURECAP-NEXT:    cret
entry:
  %cmp = icmp ugt i8 addrspace(200)* %a, %b
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @ge(i8 addrspace(200)* %a, i8 addrspace(200)* %b) nounwind {
; HYBRID-LABEL: ge:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    sltu a0, a0, a1
; HYBRID-NEXT:    xori a0, a0, 1
; HYBRID-NEXT:    ret
;
; PURECAP-LABEL: ge:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    sltu a0, a0, a1
; PURECAP-NEXT:    xori a0, a0, 1
; PURECAP-NEXT:    cret
entry:
  %cmp = icmp uge i8 addrspace(200)* %a, %b
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i8 addrspace(200)* @select_lt(i8 addrspace(200)* %a, i8 addrspace(200)* %b) nounwind {
; HYBRID-LABEL: select_lt:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    sltu a2, a0, a1
; HYBRID-NEXT:    bnez a2, .LBB4_2
; HYBRID-NEXT:  # %bb.1: # %entry
; HYBRID-NEXT:    cmove ca0, ca1
; HYBRID-NEXT:  .LBB4_2: # %entry
; HYBRID-NEXT:    ret
;
; PURECAP-LABEL: select_lt:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    sltu a2, a0, a1
; PURECAP-NEXT:    bnez a2, .LBB4_2
; PURECAP-NEXT:  # %bb.1: # %entry
; PURECAP-NEXT:    cmove ca0, ca1
; PURECAP-NEXT:  .LBB4_2: # %entry
; PURECAP-NEXT:    cret
entry:
  %cmp = icmp ult i8 addrspace(200)* %a, %b
  %cond = select i1 %cmp, i8 addrspace(200)* %a, i8 addrspace(200)* %b
  ret i8 addrspace(200)* %cond
}

define i8 addrspace(200)* @select_le(i8 addrspace(200)* %a, i8 addrspace(200)* %b) nounwind {
; HYBRID-LABEL: select_le:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    sltu a2, a1, a0
; HYBRID-NEXT:    xori a2, a2, 1
; HYBRID-NEXT:    bnez a2, .LBB5_2
; HYBRID-NEXT:  # %bb.1: # %entry
; HYBRID-NEXT:    cmove ca0, ca1
; HYBRID-NEXT:  .LBB5_2: # %entry
; HYBRID-NEXT:    ret
;
; PURECAP-LABEL: select_le:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    sltu a2, a1, a0
; PURECAP-NEXT:    xori a2, a2, 1
; PURECAP-NEXT:    bnez a2, .LBB5_2
; PURECAP-NEXT:  # %bb.1: # %entry
; PURECAP-NEXT:    cmove ca0, ca1
; PURECAP-NEXT:  .LBB5_2: # %entry
; PURECAP-NEXT:    cret
entry:
  %cmp = icmp ule i8 addrspace(200)* %a, %b
  %cond = select i1 %cmp, i8 addrspace(200)* %a, i8 addrspace(200)* %b
  ret i8 addrspace(200)* %cond
}

define i8 addrspace(200)* @select_gt(i8 addrspace(200)* %a, i8 addrspace(200)* %b) nounwind {
; HYBRID-LABEL: select_gt:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    sltu a2, a1, a0
; HYBRID-NEXT:    bnez a2, .LBB6_2
; HYBRID-NEXT:  # %bb.1: # %entry
; HYBRID-NEXT:    cmove ca0, ca1
; HYBRID-NEXT:  .LBB6_2: # %entry
; HYBRID-NEXT:    ret
;
; PURECAP-LABEL: select_gt:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    sltu a2, a1, a0
; PURECAP-NEXT:    bnez a2, .LBB6_2
; PURECAP-NEXT:  # %bb.1: # %entry
; PURECAP-NEXT:    cmove ca0, ca1
; PURECAP-NEXT:  .LBB6_2: # %entry
; PURECAP-NEXT:    cret
entry:
  %cmp = icmp ugt i8 addrspace(200)* %a, %b
  %cond = select i1 %cmp, i8 addrspace(200)* %a, i8 addrspace(200)* %b
  ret i8 addrspace(200)* %cond
}

define i8 addrspace(200)* @select_ge(i8 addrspace(200)* %a, i8 addrspace(200)* %b) nounwind {
; HYBRID-LABEL: select_ge:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    sltu a2, a0, a1
; HYBRID-NEXT:    xori a2, a2, 1
; HYBRID-NEXT:    bnez a2, .LBB7_2
; HYBRID-NEXT:  # %bb.1: # %entry
; HYBRID-NEXT:    cmove ca0, ca1
; HYBRID-NEXT:  .LBB7_2: # %entry
; HYBRID-NEXT:    ret
;
; PURECAP-LABEL: select_ge:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    sltu a2, a0, a1
; PURECAP-NEXT:    xori a2, a2, 1
; PURECAP-NEXT:    bnez a2, .LBB7_2
; PURECAP-NEXT:  # %bb.1: # %entry
; PURECAP-NEXT:    cmove ca0, ca1
; PURECAP-NEXT:  .LBB7_2: # %entry
; PURECAP-NEXT:    cret
entry:
  %cmp = icmp uge i8 addrspace(200)* %a, %b
  %cond = select i1 %cmp, i8 addrspace(200)* %a, i8 addrspace(200)* %b
  ret i8 addrspace(200)* %cond
}

declare i32 @func1() nounwind noreturn
declare i32 @func2() nounwind noreturn

define i32 @branch_lt(i8 addrspace(200)* %a, i8 addrspace(200)* %b) nounwind noreturn {
; HYBRID-LABEL: branch_lt:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    sltu a0, a0, a1
; HYBRID-NEXT:    xori a0, a0, 1
; HYBRID-NEXT:    bnez a0, .LBB8_2
; HYBRID-NEXT:  # %bb.1: # %if.then
; HYBRID-NEXT:    tail func1@plt
; HYBRID-NEXT:  .LBB8_2: # %if.end
; HYBRID-NEXT:    tail func2@plt
;
; PURECAP-LABEL: branch_lt:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    sltu a0, a0, a1
; PURECAP-NEXT:    xori a0, a0, 1
; PURECAP-NEXT:    bnez a0, .LBB8_2
; PURECAP-NEXT:  # %bb.1: # %if.then
; PURECAP-NEXT:  .LBB8_3: # %if.then
; PURECAP-NEXT:    # Label of block must be emitted
; PURECAP-NEXT:    auipcc ca5, %captab_pcrel_hi(func1)
; PURECAP-NEXT:    clc ca5, %pcrel_lo(.LBB8_3)(ca5)
; PURECAP-NEXT:    cjr ca5
; PURECAP-NEXT:  .LBB8_2: # %if.end
; PURECAP-NEXT:  .LBB8_4: # %if.end
; PURECAP-NEXT:    # Label of block must be emitted
; PURECAP-NEXT:    auipcc ca5, %captab_pcrel_hi(func2)
; PURECAP-NEXT:    clc ca5, %pcrel_lo(.LBB8_4)(ca5)
; PURECAP-NEXT:    cjr ca5
entry:
  %cmp = icmp ult i8 addrspace(200)* %a, %b
  br i1 %cmp, label %if.then, label %if.end
if.then:
  %retval1 = tail call i32 @func1()
  ret i32 %retval1
if.end:
  %retval2 = tail call i32 @func2()
  ret i32 %retval2
}

define i32 @branch_le(i8 addrspace(200)* %a, i8 addrspace(200)* %b) nounwind noreturn {
; HYBRID-LABEL: branch_le:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    sltu a0, a1, a0
; HYBRID-NEXT:    bnez a0, .LBB9_2
; HYBRID-NEXT:  # %bb.1: # %if.then
; HYBRID-NEXT:    tail func1@plt
; HYBRID-NEXT:  .LBB9_2: # %if.end
; HYBRID-NEXT:    tail func2@plt
;
; PURECAP-LABEL: branch_le:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    sltu a0, a1, a0
; PURECAP-NEXT:    bnez a0, .LBB9_2
; PURECAP-NEXT:  # %bb.1: # %if.then
; PURECAP-NEXT:  .LBB9_3: # %if.then
; PURECAP-NEXT:    # Label of block must be emitted
; PURECAP-NEXT:    auipcc ca5, %captab_pcrel_hi(func1)
; PURECAP-NEXT:    clc ca5, %pcrel_lo(.LBB9_3)(ca5)
; PURECAP-NEXT:    cjr ca5
; PURECAP-NEXT:  .LBB9_2: # %if.end
; PURECAP-NEXT:  .LBB9_4: # %if.end
; PURECAP-NEXT:    # Label of block must be emitted
; PURECAP-NEXT:    auipcc ca5, %captab_pcrel_hi(func2)
; PURECAP-NEXT:    clc ca5, %pcrel_lo(.LBB9_4)(ca5)
; PURECAP-NEXT:    cjr ca5
entry:
  %cmp = icmp ule i8 addrspace(200)* %a, %b
  br i1 %cmp, label %if.then, label %if.end
if.then:
  %retval1 = tail call i32 @func1()
  ret i32 %retval1
if.end:
  %retval2 = tail call i32 @func2()
  ret i32 %retval2
}

define i32 @branch_gt(i8 addrspace(200)* %a, i8 addrspace(200)* %b) nounwind noreturn {
; HYBRID-LABEL: branch_gt:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    sltu a0, a1, a0
; HYBRID-NEXT:    xori a0, a0, 1
; HYBRID-NEXT:    bnez a0, .LBB10_2
; HYBRID-NEXT:  # %bb.1: # %if.then
; HYBRID-NEXT:    tail func1@plt
; HYBRID-NEXT:  .LBB10_2: # %if.end
; HYBRID-NEXT:    tail func2@plt
;
; PURECAP-LABEL: branch_gt:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    sltu a0, a1, a0
; PURECAP-NEXT:    xori a0, a0, 1
; PURECAP-NEXT:    bnez a0, .LBB10_2
; PURECAP-NEXT:  # %bb.1: # %if.then
; PURECAP-NEXT:  .LBB10_3: # %if.then
; PURECAP-NEXT:    # Label of block must be emitted
; PURECAP-NEXT:    auipcc ca5, %captab_pcrel_hi(func1)
; PURECAP-NEXT:    clc ca5, %pcrel_lo(.LBB10_3)(ca5)
; PURECAP-NEXT:    cjr ca5
; PURECAP-NEXT:  .LBB10_2: # %if.end
; PURECAP-NEXT:  .LBB10_4: # %if.end
; PURECAP-NEXT:    # Label of block must be emitted
; PURECAP-NEXT:    auipcc ca5, %captab_pcrel_hi(func2)
; PURECAP-NEXT:    clc ca5, %pcrel_lo(.LBB10_4)(ca5)
; PURECAP-NEXT:    cjr ca5
entry:
  %cmp = icmp ugt i8 addrspace(200)* %a, %b
  br i1 %cmp, label %if.then, label %if.end
if.then:
  %retval1 = tail call i32 @func1()
  ret i32 %retval1
if.end:
  %retval2 = tail call i32 @func2()
  ret i32 %retval2
}

define i32 @branch_ge(i8 addrspace(200)* %a, i8 addrspace(200)* %b) nounwind noreturn {
; HYBRID-LABEL: branch_ge:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    sltu a0, a0, a1
; HYBRID-NEXT:    bnez a0, .LBB11_2
; HYBRID-NEXT:  # %bb.1: # %if.then
; HYBRID-NEXT:    tail func1@plt
; HYBRID-NEXT:  .LBB11_2: # %if.end
; HYBRID-NEXT:    tail func2@plt
;
; PURECAP-LABEL: branch_ge:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    sltu a0, a0, a1
; PURECAP-NEXT:    bnez a0, .LBB11_2
; PURECAP-NEXT:  # %bb.1: # %if.then
; PURECAP-NEXT:  .LBB11_3: # %if.then
; PURECAP-NEXT:    # Label of block must be emitted
; PURECAP-NEXT:    auipcc ca5, %captab_pcrel_hi(func1)
; PURECAP-NEXT:    clc ca5, %pcrel_lo(.LBB11_3)(ca5)
; PURECAP-NEXT:    cjr ca5
; PURECAP-NEXT:  .LBB11_2: # %if.end
; PURECAP-NEXT:  .LBB11_4: # %if.end
; PURECAP-NEXT:    # Label of block must be emitted
; PURECAP-NEXT:    auipcc ca5, %captab_pcrel_hi(func2)
; PURECAP-NEXT:    clc ca5, %pcrel_lo(.LBB11_4)(ca5)
; PURECAP-NEXT:    cjr ca5
entry:
  %cmp = icmp uge i8 addrspace(200)* %a, %b
  br i1 %cmp, label %if.then, label %if.end
if.then:
  %retval1 = tail call i32 @func1()
  ret i32 %retval1
if.end:
  %retval2 = tail call i32 @func2()
  ret i32 %retval2
}
