; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %riscv64_cheri_llc -verify-machineinstrs < %s \
; RUN:   | FileCheck --check-prefix=CHECK-LP64 %s

declare i64 @llvm.cheri.cap.diff(i8 addrspace(200) *, i8 addrspace(200) *)

; DDC-relative loads

define i64 @ddc_lb(i8 *%ptr) nounwind {
; CHECK-LP64-LABEL: ddc_lb:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    lb a1, 0(a0)
; CHECK-LP64-NEXT:    lb a0, 1(a0)
; CHECK-LP64-NEXT:    mv a0, a1
; CHECK-LP64-NEXT:    ret
  %1 = load i8, i8 *%ptr
  %2 = sext i8 %1 to i64
  %3 = getelementptr i8, i8 *%ptr, i32 1
  ; Unused to test anyext
  %4 = load volatile i8, i8 *%3
  ret i64 %2
}

define i64 @ddc_lh(i16 *%ptr) nounwind {
; CHECK-LP64-LABEL: ddc_lh:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    lh a1, 0(a0)
; CHECK-LP64-NEXT:    lh a0, 4(a0)
; CHECK-LP64-NEXT:    mv a0, a1
; CHECK-LP64-NEXT:    ret
  %1 = load i16, i16 *%ptr
  %2 = sext i16 %1 to i64
  %3 = getelementptr i16, i16 *%ptr, i32 2
  ; Unused to test anyext
  %4 = load volatile i16, i16 *%3
  ret i64 %2
}

define i64 @ddc_lw(i32 *%ptr) nounwind {
; CHECK-LP64-LABEL: ddc_lw:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    lw a1, 0(a0)
; CHECK-LP64-NEXT:    lw a0, 12(a0)
; CHECK-LP64-NEXT:    mv a0, a1
; CHECK-LP64-NEXT:    ret
  %1 = load i32, i32 *%ptr
  %2 = sext i32 %1 to i64
  %3 = getelementptr i32, i32 *%ptr, i32 3
  ; Unused to test anyext
  %4 = load volatile i32, i32 *%3
  ret i64 %2
}

define i64 @ddc_ld(i64 *%ptr) nounwind {
; CHECK-LP64-LABEL: ddc_ld:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    ld a1, 0(a0)
; CHECK-LP64-NEXT:    ld a0, 32(a0)
; CHECK-LP64-NEXT:    mv a0, a1
; CHECK-LP64-NEXT:    ret
  %1 = load i64, i64 *%ptr
  %2 = getelementptr i64, i64 *%ptr, i32 4
  %3 = load volatile i64, i64 *%2
  ret i64 %1
}

define i64 @ddc_lbu(i8 *%ptr) nounwind {
; CHECK-LP64-LABEL: ddc_lbu:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    lbu a1, 0(a0)
; CHECK-LP64-NEXT:    lbu a0, 5(a0)
; CHECK-LP64-NEXT:    add a0, a1, a0
; CHECK-LP64-NEXT:    ret
  %1 = load i8, i8 *%ptr
  %2 = zext i8 %1 to i64
  %3 = getelementptr i8, i8 *%ptr, i32 5
  %4 = load i8, i8 *%3
  %5 = zext i8 %4 to i64
  %6 = add i64 %2, %5
  ret i64 %6
}

define i64 @ddc_lhu(i16 *%ptr) nounwind {
; CHECK-LP64-LABEL: ddc_lhu:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    lhu a1, 0(a0)
; CHECK-LP64-NEXT:    lhu a0, 12(a0)
; CHECK-LP64-NEXT:    add a0, a1, a0
; CHECK-LP64-NEXT:    ret
  %1 = load i16, i16 *%ptr
  %2 = zext i16 %1 to i64
  %3 = getelementptr i16, i16 *%ptr, i32 6
  %4 = load i16, i16 *%3
  %5 = zext i16 %4 to i64
  %6 = add i64 %2, %5
  ret i64 %6
}

define i64 @ddc_lwu(i32 *%ptr) nounwind {
; CHECK-LP64-LABEL: ddc_lwu:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    lwu a1, 0(a0)
; CHECK-LP64-NEXT:    lwu a0, 28(a0)
; CHECK-LP64-NEXT:    add a0, a1, a0
; CHECK-LP64-NEXT:    ret
  %1 = load i32, i32 *%ptr
  %2 = zext i32 %1 to i64
  %3 = getelementptr i32, i32 *%ptr, i32 7
  %4 = load i32, i32 *%3
  %5 = zext i32 %4 to i64
  %6 = add i64 %2, %5
  ret i64 %6
}

define i64 @ddc_lc(i8 addrspace(200) **%ptr) nounwind {
; CHECK-LP64-LABEL: ddc_lc:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    lc ca1, 0(a0)
; CHECK-LP64-NEXT:    lc ca0, 128(a0)
; CHECK-LP64-NEXT:    csub a0, ca1, ca0
; CHECK-LP64-NEXT:    ret
  %1 = load i8 addrspace(200) *, i8 addrspace(200) **%ptr
  %2 = getelementptr i8 addrspace(200) *, i8 addrspace(200) **%ptr, i32 8
  %3 = load i8 addrspace(200) *, i8 addrspace(200) **%2
  %4 = call i64 @llvm.cheri.cap.diff(i8 addrspace(200) *%1, i8 addrspace(200) *%3)
  ret i64 %4
}

; DDC-relative stores

define void @ddc_sb(i8 *%ptr, i8 %val) nounwind {
; CHECK-LP64-LABEL: ddc_sb:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    sb a1, 0(a0)
; CHECK-LP64-NEXT:    sb a1, 9(a0)
; CHECK-LP64-NEXT:    ret
  store i8 %val, i8 *%ptr
  %1 = getelementptr i8, i8 *%ptr, i32 9
  store i8 %val, i8 *%1
  ret void
}

define void @ddc_sh(i16 *%ptr, i16 %val) nounwind {
; CHECK-LP64-LABEL: ddc_sh:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    sh a1, 0(a0)
; CHECK-LP64-NEXT:    sh a1, 20(a0)
; CHECK-LP64-NEXT:    ret
  store i16 %val, i16 *%ptr
  %1 = getelementptr i16, i16 *%ptr, i32 10
  store i16 %val, i16 *%1
  ret void
}

define void @ddc_sw(i32 *%ptr, i32 %val) nounwind {
; CHECK-LP64-LABEL: ddc_sw:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    sw a1, 0(a0)
; CHECK-LP64-NEXT:    sw a1, 44(a0)
; CHECK-LP64-NEXT:    ret
  store i32 %val, i32 *%ptr
  %1 = getelementptr i32, i32 *%ptr, i32 11
  store i32 %val, i32 *%1
  ret void
}

define void @ddc_sd(i64 *%ptr, i64 %val) nounwind {
; CHECK-LP64-LABEL: ddc_sd:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    sd a1, 0(a0)
; CHECK-LP64-NEXT:    sd a1, 96(a0)
; CHECK-LP64-NEXT:    ret
  store i64 %val, i64 *%ptr
  %1 = getelementptr i64, i64 *%ptr, i32 12
  store i64 %val, i64 *%1
  ret void
}

define void @ddc_sc(i8 addrspace(200) **%ptr, i8 addrspace(200) *%val) nounwind {
; CHECK-LP64-LABEL: ddc_sc:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    sc ca1, 0(a0)
; CHECK-LP64-NEXT:    sc ca1, 208(a0)
; CHECK-LP64-NEXT:    ret
  store i8 addrspace(200) *%val, i8 addrspace(200) **%ptr
  %1 = getelementptr i8 addrspace(200) *, i8 addrspace(200) **%ptr, i32 13
  store i8 addrspace(200) *%val, i8 addrspace(200) **%1
  ret void
}

; Capability-relative loads

define i64 @cap_lb(i8 addrspace(200) *%cap) nounwind {
; CHECK-LP64-LABEL: cap_lb:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    lb.cap a1, (ca0)
; CHECK-LP64-NEXT:    cincoffset ca0, ca0, 14
; CHECK-LP64-NEXT:    lb.cap a0, (ca0)
; CHECK-LP64-NEXT:    mv a0, a1
; CHECK-LP64-NEXT:    ret
  %1 = load i8, i8 addrspace(200) *%cap
  %2 = sext i8 %1 to i64
  %3 = getelementptr i8, i8 addrspace(200) *%cap, i32 14
  ; Unused to test anyext
  %4 = load volatile i8, i8 addrspace(200) *%3
  ret i64 %2
}

define i64 @cap_lh(i16 addrspace(200) *%cap) nounwind {
; CHECK-LP64-LABEL: cap_lh:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    lh.cap a1, (ca0)
; CHECK-LP64-NEXT:    cincoffset ca0, ca0, 30
; CHECK-LP64-NEXT:    lh.cap a0, (ca0)
; CHECK-LP64-NEXT:    mv a0, a1
; CHECK-LP64-NEXT:    ret
  %1 = load i16, i16 addrspace(200) *%cap
  %2 = sext i16 %1 to i64
  %3 = getelementptr i16, i16 addrspace(200) *%cap, i32 15
  ; Unused to test anyext
  %4 = load volatile i16, i16 addrspace(200) *%3
  ret i64 %2
}

define i64 @cap_lw(i32 addrspace(200) *%cap) nounwind {
; CHECK-LP64-LABEL: cap_lw:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    lw.cap a1, (ca0)
; CHECK-LP64-NEXT:    cincoffset ca0, ca0, 64
; CHECK-LP64-NEXT:    lw.cap a0, (ca0)
; CHECK-LP64-NEXT:    mv a0, a1
; CHECK-LP64-NEXT:    ret
  %1 = load i32, i32 addrspace(200) *%cap
  %2 = sext i32 %1 to i64
  %3 = getelementptr i32, i32 addrspace(200) *%cap, i32 16
  ; Unused to test anyext
  %4 = load volatile i32, i32 addrspace(200) *%3
  ret i64 %2
}

define i64 @cap_ld(i64 addrspace(200) *%cap) nounwind {
; CHECK-LP64-LABEL: cap_ld:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    ld.cap a1, (ca0)
; CHECK-LP64-NEXT:    cincoffset ca0, ca0, 136
; CHECK-LP64-NEXT:    ld.cap a0, (ca0)
; CHECK-LP64-NEXT:    mv a0, a1
; CHECK-LP64-NEXT:    ret
  %1 = load i64, i64 addrspace(200) *%cap
  %2 = getelementptr i64, i64 addrspace(200) *%cap, i32 17
  %3 = load volatile i64, i64 addrspace(200) *%2
  ret i64 %1
}

define i64 @cap_lbu(i8 addrspace(200) *%cap) nounwind {
; CHECK-LP64-LABEL: cap_lbu:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    lbu.cap a1, (ca0)
; CHECK-LP64-NEXT:    cincoffset ca0, ca0, 18
; CHECK-LP64-NEXT:    lbu.cap a0, (ca0)
; CHECK-LP64-NEXT:    add a0, a1, a0
; CHECK-LP64-NEXT:    ret
  %1 = load i8, i8 addrspace(200) *%cap
  %2 = zext i8 %1 to i64
  %3 = getelementptr i8, i8 addrspace(200) *%cap, i32 18
  %4 = load i8, i8 addrspace(200) *%3
  %5 = zext i8 %4 to i64
  %6 = add i64 %2, %5
  ret i64 %6
}

define i64 @cap_lhu(i16 addrspace(200) *%cap) nounwind {
; CHECK-LP64-LABEL: cap_lhu:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    lhu.cap a1, (ca0)
; CHECK-LP64-NEXT:    cincoffset ca0, ca0, 38
; CHECK-LP64-NEXT:    lhu.cap a0, (ca0)
; CHECK-LP64-NEXT:    add a0, a1, a0
; CHECK-LP64-NEXT:    ret
  %1 = load i16, i16 addrspace(200) *%cap
  %2 = zext i16 %1 to i64
  %3 = getelementptr i16, i16 addrspace(200) *%cap, i32 19
  %4 = load i16, i16 addrspace(200) *%3
  %5 = zext i16 %4 to i64
  %6 = add i64 %2, %5
  ret i64 %6
}

define i64 @cap_lwu(i32 addrspace(200) *%cap) nounwind {
; CHECK-LP64-LABEL: cap_lwu:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    lwu.cap a1, (ca0)
; CHECK-LP64-NEXT:    cincoffset ca0, ca0, 80
; CHECK-LP64-NEXT:    lwu.cap a0, (ca0)
; CHECK-LP64-NEXT:    add a0, a1, a0
; CHECK-LP64-NEXT:    ret
  %1 = load i32, i32 addrspace(200) *%cap
  %2 = zext i32 %1 to i64
  %3 = getelementptr i32, i32 addrspace(200) *%cap, i32 20
  %4 = load i32, i32 addrspace(200) *%3
  %5 = zext i32 %4 to i64
  %6 = add i64 %2, %5
  ret i64 %6
}

define i64 @cap_lc(i8 addrspace(200) *addrspace(200) *%cap) nounwind {
; CHECK-LP64-LABEL: cap_lc:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    lc.cap ca1, (ca0)
; CHECK-LP64-NEXT:    cincoffset ca0, ca0, 336
; CHECK-LP64-NEXT:    lc.cap ca0, (ca0)
; CHECK-LP64-NEXT:    csub a0, ca1, ca0
; CHECK-LP64-NEXT:    ret
  %1 = load i8 addrspace(200) *, i8 addrspace(200) *addrspace(200) *%cap
  %2 = getelementptr i8 addrspace(200) *, i8 addrspace(200) *addrspace(200) *%cap, i32 21
  %3 = load i8 addrspace(200) *, i8 addrspace(200) *addrspace(200) *%2
  %4 = call i64 @llvm.cheri.cap.diff(i8 addrspace(200) *%1, i8 addrspace(200) *%3)
  ret i64 %4
}

; Capability-relative stores

define void @cap_sb(i8 addrspace(200) *%cap, i8 %val) nounwind {
; CHECK-LP64-LABEL: cap_sb:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    sb.cap a1, (ca0)
; CHECK-LP64-NEXT:    cincoffset ca0, ca0, 22
; CHECK-LP64-NEXT:    sb.cap a1, (ca0)
; CHECK-LP64-NEXT:    ret
  store i8 %val, i8 addrspace(200) *%cap
  %1 = getelementptr i8, i8 addrspace(200) *%cap, i32 22
  store i8 %val, i8 addrspace(200) *%1
  ret void
}

define void @cap_sh(i16 addrspace(200) *%cap, i16 %val) nounwind {
; CHECK-LP64-LABEL: cap_sh:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    sh.cap a1, (ca0)
; CHECK-LP64-NEXT:    cincoffset ca0, ca0, 46
; CHECK-LP64-NEXT:    sh.cap a1, (ca0)
; CHECK-LP64-NEXT:    ret
  store i16 %val, i16 addrspace(200) *%cap
  %1 = getelementptr i16, i16 addrspace(200) *%cap, i32 23
  store i16 %val, i16 addrspace(200) *%1
  ret void
}

define void @cap_sw(i32 addrspace(200) *%cap, i32 %val) nounwind {
; CHECK-LP64-LABEL: cap_sw:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    sw.cap a1, (ca0)
; CHECK-LP64-NEXT:    cincoffset ca0, ca0, 96
; CHECK-LP64-NEXT:    sw.cap a1, (ca0)
; CHECK-LP64-NEXT:    ret
  store i32 %val, i32 addrspace(200) *%cap
  %1 = getelementptr i32, i32 addrspace(200) *%cap, i32 24
  store i32 %val, i32 addrspace(200) *%1
  ret void
}

define void @cap_sd(i64 addrspace(200) *%cap, i64 %val) nounwind {
; CHECK-LP64-LABEL: cap_sd:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    sd.cap a1, (ca0)
; CHECK-LP64-NEXT:    cincoffset ca0, ca0, 200
; CHECK-LP64-NEXT:    sd.cap a1, (ca0)
; CHECK-LP64-NEXT:    ret
  store i64 %val, i64 addrspace(200) *%cap
  %1 = getelementptr i64, i64 addrspace(200) *%cap, i32 25
  store i64 %val, i64 addrspace(200) *%1
  ret void
}

define void @cap_sc(i8 addrspace(200) *addrspace(200) *%cap, i8 addrspace(200) *%val) nounwind {
; CHECK-LP64-LABEL: cap_sc:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    sc.cap ca1, (ca0)
; CHECK-LP64-NEXT:    cincoffset ca0, ca0, 416
; CHECK-LP64-NEXT:    sc.cap ca1, (ca0)
; CHECK-LP64-NEXT:    ret
  store i8 addrspace(200) *%val, i8 addrspace(200) *addrspace(200) *%cap
  %1 = getelementptr i8 addrspace(200) *, i8 addrspace(200) *addrspace(200) *%cap, i32 26
  store i8 addrspace(200) *%val, i8 addrspace(200) *addrspace(200) *%1
  ret void
}
