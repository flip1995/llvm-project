# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# REQUIRES: asserts
## The delay slot filler would previously move BUNDLE instructions into the delay slot.
## This caused the entire PC-relative address computation to move into the next basic block and result in
## one of the branches reading uninitialized values for the $cgp register :(
## Check that the delay slot filler skips BUNDLES. In theory we may be able to put some of the instructions in the delay slot but determining which ones is difficult.
## FIXME: Should upstream this (but it shouldn't matter since there aren't any uses of BUNDLE in the Mips backend)

# RUN: %cheri_purecap_llc %s -start-before=mips-delay-slot-filler -stop-after=mips-delay-slot-filler \
# RUN:   -verify-machineinstrs -o - -debug-only="mips-delay-slot-filler" 2>%t.dbg | FileCheck %s
# RUN: FileCheck %s -input-file=%t.dbg -check-prefix=DBG
# DBG:      mips-delay-slot-filler: checking instruction for delay slot:   BUNDLE
# DBG-NEXT: mips-delay-slot-filler: ignoring BUNDLE instruction for delay slot:
# DBG-NEXT: mips-delay-slot-filler: checking instruction for delay slot: CFI_INSTRUCTION offset $c17, -16
# DBG-NEXT: mips-delay-slot-filler: should terminate search:   CFI_INSTRUCTION offset $c17, -16


--- |
  ; ModuleID = '/Users/alex/cheri/llvm-project/llvm/test/CodeGen/Mips/cheri/cheri-cap-table-hoist-err.c'
  source_filename = "/Users/alex/cheri/llvm-project/llvm/test/CodeGen/Mips/cheri/cheri-cap-table-hoist-err.c"
  target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"
  target triple = "cheri-unknown-freebsd-purecap"

  ; Function Attrs: nounwind
  define i8 addrspace(200)* @__simple_malloc(i64 zeroext %nbytes) local_unnamed_addr addrspace(200) #0 {
  entry:
    %cmp = icmp eq i64 %nbytes, 0
    br i1 %cmp, label %if.else, label %if.then

  if.then:                                          ; preds = %entry
    %call = tail call i8 addrspace(200)* @func_a(i64 zeroext %nbytes) #2
    br label %return

  if.else:                                          ; preds = %entry
    %call1 = tail call i8 addrspace(200)* @func_b(i64 zeroext 0) #2
    br label %return

  return:                                           ; preds = %if.else, %if.then
    %retval.0 = phi i8 addrspace(200)* [ %call, %if.then ], [ %call1, %if.else ]
    ret i8 addrspace(200)* %retval.0
  }

  declare i8 addrspace(200)* @func_a(i64 zeroext) local_unnamed_addr addrspace(200) #1

  declare i8 addrspace(200)* @func_b(i64 zeroext) local_unnamed_addr addrspace(200) #1

  ; Function Attrs: nounwind
  declare void @llvm.stackprotector(i8*, i8**) addrspace(200) #2

  attributes #0 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="cheri128" "target-features"="+cheri128,+chericap" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="cheri128" "target-features"="+cheri128,+chericap" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #2 = { nounwind }

  !llvm.module.flags = !{!0}
  !llvm.ident = !{!1}

  !0 = !{i32 1, !"wchar_size", i32 4}
  !1 = !{!"clang version 10.0.0 (https://github.com/CTSRD-CHERI/llvm-project ef7774b0d4870773e110ecde78be82b894049c92)"}

...
---
name:            __simple_malloc
alignment:       8
exposesReturnsTwice: false
legalized:       false
regBankSelected: false
selected:        false
failedISel:      false
tracksRegLiveness: true
hasWinCFI:       false
registers:       []
liveins:
  - { reg: '$a0_64', virtual-reg: '' }
frameInfo:
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       16
  offsetAdjustment: 0
  maxAlignment:    16
  adjustsStack:    true
  hasCalls:        true
  stackProtector:  ''
  maxCallFrameSize: 0
  cvBytesOfCalleeSavedRegisters: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
  localFrameSize:  0
  savePoint:       ''
  restorePoint:    ''
fixedStack:      []
stack:
  - { id: 0, name: '', type: spill-slot, offset: -16, size: 16, alignment: 16,
      stack-id: default, callee-saved-register: '$c17', callee-saved-restored: true,
      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
callSites:       []
constants:       []
machineFunctionInfo: {}
body:             |
  ; CHECK-LABEL: name: __simple_malloc
  ; CHECK: bb.0.entry:
  ; CHECK:   successors: %bb.2(0x30000000), %bb.1(0x50000000)
  ; CHECK:   $c11 = CIncOffsetImm $c11, -16
  ; CHECK:   CFI_INSTRUCTION def_cfa_offset 16
  ; CHECK:   STORECAP killed $c17, $zero_64, 0, $c11 :: (store 16 into %stack.0)
  ; CHECK:   CFI_INSTRUCTION offset $c17, -16
  ; CHECK:   BUNDLE implicit-def $c1, implicit-def dead $at_64, implicit-def $at {
  ; CHECK:     $c1 = CGetPCC
  ; CHECK:     $at_64 = LUi64 target-flags(mips-pcrel-hi16) &_CHERI_CAPABILITY_TABLE_ + 4
  ; CHECK:     $at_64 = DADDiu internal killed $at_64, target-flags(mips-pcrel-lo16) &_CHERI_CAPABILITY_TABLE_ + 8
  ; CHECK:     $c1 = CIncOffset internal killed $c1, internal killed $at_64
  ; CHECK:   }
  ; CHECK:   BEQ64 renamable $a0_64, $zero_64, %bb.2, implicit-def $at {
  ; CHECK:     NOP
  ; CHECK:   }
  ; CHECK: bb.1.if.then:
  ; CHECK:   renamable $c12 = LOADCAP_BigImm target-flags(mips-captable20-call) @func_a, killed renamable $c1 :: (load 16 from call-entry @func_a)
  ; CHECK:   CapJumpLinkPseudo killed $c12, csr_cheri_purecap, implicit-def dead $c17, implicit-def dead $c26, implicit killed $a0_64, implicit-def $c11, implicit-def $c3 {
  ; CHECK:     NOP
  ; CHECK:   }
  ; CHECK:   $c17 = LOADCAP $zero_64, 0, $c11 :: (load 16 from %stack.0)
  ; CHECK:   PseudoReturnCap $c17 {
  ; CHECK:     $c11 = CIncOffsetImm $c11, 16
  ; CHECK:   }
  ; CHECK: bb.2.if.else:
  ; CHECK:   renamable $c12 = LOADCAP_BigImm target-flags(mips-captable20-call) @func_b, killed renamable $c1 :: (load 16 from call-entry @func_b)
  ; CHECK:   CapJumpLinkPseudo killed $c12, csr_cheri_purecap, implicit-def dead $c17, implicit-def dead $c26, implicit killed $a0_64, implicit-def $c11, implicit-def $c3 {
  ; CHECK:     $a0_64 = DADDiu $zero_64, 0
  ; CHECK:   }
  ; CHECK:   $c17 = LOADCAP $zero_64, 0, $c11 :: (load 16 from %stack.0)
  ; CHECK:   PseudoReturnCap $c17 {
  ; CHECK:     $c11 = CIncOffsetImm $c11, 16
  ; CHECK:   }
  bb.0.entry:
    successors: %bb.2(0x30000000), %bb.1(0x50000000)
    liveins: $a0_64, $c17, $ddc

    $c11 = CIncOffsetImm $c11, -16
    CFI_INSTRUCTION def_cfa_offset 16
    STORECAP killed $c17, $zero_64, 0, $c11 :: (store 16 into %stack.0)
    CFI_INSTRUCTION offset $c17, -16
    BUNDLE implicit-def $c1, implicit-def dead $at_64, implicit-def $at {
      $c1 = CGetPCC
      $at_64 = LUi64 target-flags(mips-pcrel-hi16) &_CHERI_CAPABILITY_TABLE_ + 4
      $at_64 = DADDiu internal killed $at_64, target-flags(mips-pcrel-lo16) &_CHERI_CAPABILITY_TABLE_ + 8
      $c1 = CIncOffset internal killed $c1, internal killed $at_64
    }
    BEQ64 renamable $a0_64, $zero_64, %bb.2, implicit-def $at

  bb.1.if.then:
    liveins: $c1, $a0_64

    renamable $c12 = LOADCAP_BigImm target-flags(mips-captable20-call) @func_a, killed renamable $c1 :: (load 16 from call-entry @func_a)
    CapJumpLinkPseudo killed $c12, csr_cheri_purecap, implicit-def dead $c17, implicit-def dead $c26, implicit killed $a0_64, implicit-def $c11, implicit-def $c3
    $c17 = LOADCAP $zero_64, 0, $c11 :: (load 16 from %stack.0)
    $c11 = CIncOffsetImm $c11, 16
    PseudoReturnCap $c17

  bb.2.if.else:
    liveins: $c1

    renamable $c12 = LOADCAP_BigImm target-flags(mips-captable20-call) @func_b, killed renamable $c1 :: (load 16 from call-entry @func_b)
    $a0_64 = DADDiu $zero_64, 0
    CapJumpLinkPseudo killed $c12, csr_cheri_purecap, implicit-def dead $c17, implicit-def dead $c26, implicit killed $a0_64, implicit-def $c11, implicit-def $c3
    $c17 = LOADCAP $zero_64, 0, $c11 :: (load 16 from %stack.0)
    $c11 = CIncOffsetImm $c11, 16
    PseudoReturnCap $c17

...
