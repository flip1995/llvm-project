# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
## Regression test found when compiling CheriBSD libc
# RUN: %cheri_purecap_llc -run-pass=cheriaddrmodefolder -verify-machineinstrs -o - %s | FileCheck %s
--- |
  target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"
  target triple = "cheri-unknown-freebsd"

  @a = external addrspace(200) global i32, align 4
  @b = external local_unnamed_addr addrspace(200) global i16, align 2

  ; Function Attrs: nounwind
  define void @d() local_unnamed_addr addrspace(200) #0 {
  entry:
    %0 = load i16, i16 addrspace(200)* @b, align 2
    %idx.ext = sext i16 %0 to i64
    %add.ptr = getelementptr inbounds i32, i32 addrspace(200)* @a, i64 %idx.ext
    br label %for.cond

  for.cond:                                         ; preds = %for.cond, %entry
    %1 = bitcast i32 addrspace(200)* %add.ptr to i8 addrspace(200)*
    %sunkaddr = getelementptr inbounds i8, i8 addrspace(200)* %1, i64 1
    %2 = bitcast i8 addrspace(200)* %sunkaddr to i32 addrspace(200)*
    store i32 0, i32 addrspace(200)* %2, align 4
    br label %for.cond
  }

  attributes #0 = { nounwind }

...
---
name:            d
alignment:       8
exposesReturnsTwice: false
legalized:       false
regBankSelected: false
selected:        false
failedISel:      false
tracksRegLiveness: true
hasWinCFI:       false
registers:
  - { id: 0, class: cherigpr, preferred-register: '' }
  - { id: 1, class: cherigpr, preferred-register: '' }
  - { id: 2, class: gpr64, preferred-register: '' }
  - { id: 3, class: cherigpr, preferred-register: '' }
  - { id: 4, class: gpr64, preferred-register: '' }
  - { id: 5, class: gpr64, preferred-register: '' }
  - { id: 6, class: cherigpr, preferred-register: '' }
  - { id: 7, class: cherigpr, preferred-register: '' }
  - { id: 8, class: gpr32, preferred-register: '' }
  - { id: 9, class: gpr64, preferred-register: '' }
  - { id: 10, class: cherigpr, preferred-register: '' }
  - { id: 11, class: cherigpr, preferred-register: '' }
  - { id: 12, class: cherigpr, preferred-register: '' }
liveins:         []
frameInfo:
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        false
  stackProtector:  ''
  maxCallFrameSize: 4294967295
  cvBytesOfCalleeSavedRegisters: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
  localFrameSize:  0
  savePoint:       ''
  restorePoint:    ''
fixedStack:      []
stack:           []
callSites:       []
constants:       []
machineFunctionInfo: {}
body:             |
  ; CHECK-LABEL: name: d
  ; CHECK: bb.0.entry:
  ; CHECK:   successors: %bb.1(0x80000000)
  ; CHECK:   [[PseudoPccRelativeAddressPostRA:%[0-9]+]]:cherigpr = PseudoPccRelativeAddressPostRA &_CHERI_CAPABILITY_TABLE_, implicit-def dead early-clobber %2
  ; CHECK:   [[LOADCAP_BigImm:%[0-9]+]]:cherigpr = LOADCAP_BigImm target-flags(mips-captable20) @b, [[PseudoPccRelativeAddressPostRA]] :: (load (s128) from cap-table)
  ; CHECK:   [[CAPLOAD16_:%[0-9]+]]:gpr64 = CAPLOAD16 $zero_64, 0, killed [[LOADCAP_BigImm]] :: (dereferenceable load (s16) from @b, addrspace 200)
  ; CHECK:   [[DSLL:%[0-9]+]]:gpr64 = DSLL [[CAPLOAD16_]], 2
  ; CHECK:   [[LOADCAP_BigImm1:%[0-9]+]]:cherigpr = LOADCAP_BigImm target-flags(mips-captable20) @a, [[PseudoPccRelativeAddressPostRA]] :: (load (s128) from cap-table)
  ; CHECK:   [[CIncOffsetImm:%[0-9]+]]:cherigpr = CIncOffsetImm [[LOADCAP_BigImm1]], 1
  ; CHECK:   [[CIncOffsetImm1:%[0-9]+]]:cherigpr = CIncOffsetImm [[LOADCAP_BigImm1]], 1
  ; CHECK:   CAPSTORE32 killed $zero, [[DSLL]], 0, killed [[CIncOffsetImm1]] :: (store (s32) into %ir.2, addrspace 200)
  ; CHECK:   [[DSLL1:%[0-9]+]]:gpr64 = DSLL killed [[CAPLOAD16_]], 2
  ; CHECK:   [[CIncOffsetImm2:%[0-9]+]]:cherigpr = CIncOffsetImm [[LOADCAP_BigImm1]], 1
  ; CHECK:   CAPSTORE32 killed $zero, killed [[DSLL1]], 0, killed [[CIncOffsetImm2]] :: (store (s32) into %ir.2, addrspace 200)
  ; CHECK: bb.1.for.cond:
  ; CHECK:   successors: %bb.1(0x80000000)
  ; CHECK:   CAPSTORE32 killed $zero, [[DSLL]], 0, [[CIncOffsetImm]] :: (store (s32) into %ir.2, addrspace 200)
  ; CHECK:   B %bb.1, implicit-def dead $at
  bb.0.entry:
    successors: %bb.1(0x80000000)

    %1:cherigpr = PseudoPccRelativeAddressPostRA &_CHERI_CAPABILITY_TABLE_, implicit-def dead early-clobber %2
    %3:cherigpr = LOADCAP_BigImm target-flags(mips-captable20) @b, %1 :: (load (s128) from cap-table)
    %4:gpr64 = CAPLOAD16 $zero_64, 0, killed %3 :: (dereferenceable load (s16) from @b, addrspace 200)
    %5:gpr64 = DSLL %4, 2
    %6:cherigpr = LOADCAP_BigImm target-flags(mips-captable20) @a, %1 :: (load (s128) from cap-table)
    %0:cherigpr = CIncOffset %6, killed %5
    %7:cherigpr = CIncOffsetImm %0, 1
    %10:cherigpr = CIncOffsetImm %0, 1
    CAPSTORE32 killed $zero, $zero_64, 0, killed %10 :: (store (s32) into %ir.2, addrspace 200)
    %9:gpr64 = DSLL killed %4, 2
    %11:cherigpr = CIncOffset killed %6, killed %9
    %12:cherigpr = CIncOffsetImm %11, 1
    CAPSTORE32 killed $zero, $zero_64, 0, killed %12 :: (store (s32) into %ir.2, addrspace 200)

  bb.1.for.cond:
    successors: %bb.1(0x80000000)
    ; The addressing folder would previously hoist %5 here, but mark it as killed.
    ; This is not valid since there is a branch to the same basic block at the end and %5 must be live
    CAPSTORE32 killed $zero, $zero_64, 0, %7 :: (store (s32) into %ir.2, addrspace 200)
    B %bb.1, implicit-def dead $at

...
