# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
## Another machine verifier error found compiling libc
# RUN: %cheri_purecap_llc -run-pass=cheriaddrmodefolder -verify-machineinstrs -o - %s | FileCheck %s
--- |
  ; ModuleID = '/Users/alex/cheri/llvm-project/llvm/test/CodeGen/Mips/cheri/_addrfolder-err.c-reduce.test.ll'
  source_filename = "/Users/alex/cheri/llvm-project/llvm/test/CodeGen/Mips/cheri/_addrfolder-err.c"
  target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"
  target triple = "cheri-unknown-freebsd"

  %struct.d.0.1.2.3.6.7.32 = type { i32, i16, [0 x i16] }

  define void @f() addrspace(200) #0 {
  entry:
    %0 = load i16, i16 addrspace(200)* getelementptr (%struct.d.0.1.2.3.6.7.32, %struct.d.0.1.2.3.6.7.32 addrspace(200)* bitcast (void () addrspace(200)* @f to %struct.d.0.1.2.3.6.7.32 addrspace(200)*), i64 0, i32 2, i64 0), align 2
    %idx.ext = sext i16 %0 to i64
    %add.ptr = getelementptr inbounds %struct.d.0.1.2.3.6.7.32, %struct.d.0.1.2.3.6.7.32 addrspace(200)* bitcast (void () addrspace(200)* @f to %struct.d.0.1.2.3.6.7.32 addrspace(200)*), i64 %idx.ext
    br label %for.cond

  for.cond:                                         ; preds = %for.cond, %entry
    %1 = bitcast %struct.d.0.1.2.3.6.7.32 addrspace(200)* %add.ptr to i8 addrspace(200)*
    %sunkaddr = getelementptr inbounds i8, i8 addrspace(200)* %1, i64 1
    %2 = bitcast i8 addrspace(200)* %sunkaddr to i32 addrspace(200)*
    %3 = load i32, i32 addrspace(200)* %2, align 4
    %conv2 = sext i32 %3 to i64
    %4 = add nsw i64 %conv2, 3
    %5 = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* null, i64 %4)
    %6 = load i8, i8 addrspace(200)* %5, align 1
    %7 = bitcast %struct.d.0.1.2.3.6.7.32 addrspace(200)* %add.ptr to i8 addrspace(200)*
    %sunkaddr1 = getelementptr inbounds i8, i8 addrspace(200)* %7, i64 1
    store i8 %6, i8 addrspace(200)* %sunkaddr1, align 1
    br label %for.cond
  }

  ; Function Attrs: nounwind readnone willreturn
  declare i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)*, i64) addrspace(200) #1

  ; Function Attrs: nounwind readnone willreturn
  declare i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)*) addrspace(200) #2

  ; Function Attrs: nounwind
  declare void @llvm.stackprotector(i8*, i8**) addrspace(200) #3

  attributes #0 = { nounwind }
  attributes #1 = { nounwind readnone willreturn }
  attributes #2 = { nounwind readnone willreturn }
  attributes #3 = { nounwind }

  !llvm.ident = !{!0}

  !0 = !{!"clang version 10.0.0 (https://github.com/CTSRD-CHERI/llvm-project bc146c2dcb6fcdd458e5c1ffcafbc301b391a2b9)"}

...
---
name:            f
alignment:       8
exposesReturnsTwice: false
legalized:       false
regBankSelected: false
selected:        false
failedISel:      false
tracksRegLiveness: true
hasWinCFI:       false
registers:
  - { id: 0, class: cherigpr, preferred-register: '' }
  - { id: 1, class: cherigpr, preferred-register: '' }
  - { id: 2, class: gpr64, preferred-register: '' }
  - { id: 3, class: cherigpr, preferred-register: '' }
  - { id: 4, class: cherigpr, preferred-register: '' }
  - { id: 5, class: gpr64, preferred-register: '' }
  - { id: 6, class: gpr64, preferred-register: '' }
  - { id: 7, class: cherigpr, preferred-register: '' }
  - { id: 8, class: gpr64, preferred-register: '' }
  - { id: 9, class: gpr64, preferred-register: '' }
  - { id: 10, class: cherigpr, preferred-register: '' }
  - { id: 11, class: cherigpr, preferred-register: '' }
  - { id: 12, class: gpr64, preferred-register: '' }
liveins:         []
frameInfo:
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        false
  stackProtector:  ''
  maxCallFrameSize: 4294967295
  cvBytesOfCalleeSavedRegisters: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
  localFrameSize:  0
  savePoint:       ''
  restorePoint:    ''
fixedStack:      []
stack:           []
callSites:       []
constants:       []
machineFunctionInfo: {}
body:             |
  ; CHECK-LABEL: name: f
  ; CHECK: bb.0.entry:
  ; CHECK:   successors: %bb.1(0x80000000)
  ; CHECK:   [[PseudoPccRelativeAddressPostRA:%[0-9]+]]:cherigpr = PseudoPccRelativeAddressPostRA &_CHERI_CAPABILITY_TABLE_, implicit-def dead early-clobber %2
  ; CHECK:   [[LOADCAP_BigImm:%[0-9]+]]:cherigpr = LOADCAP_BigImm target-flags(mips-captable20) @f, [[PseudoPccRelativeAddressPostRA]] :: (load (s128) from cap-table)
  ; CHECK:   [[CAPLOAD16_:%[0-9]+]]:gpr64 = CAPLOAD16 $zero_64, 6, [[LOADCAP_BigImm]] :: (load (s16) from `i16 addrspace(200)* getelementptr (%struct.d.0.1.2.3.6.7.32, %struct.d.0.1.2.3.6.7.32 addrspace(200)* bitcast (void () addrspace(200)* @f to %struct.d.0.1.2.3.6.7.32 addrspace(200)*), i64 0, i32 2, i64 0)`, addrspace 200)
  ; CHECK:   [[DSLL:%[0-9]+]]:gpr64 = DSLL killed [[CAPLOAD16_]], 3
  ; CHECK:   [[CIncOffset:%[0-9]+]]:cherigpr = CIncOffset [[LOADCAP_BigImm]], [[DSLL]]
  ; CHECK:   [[CIncOffsetImm:%[0-9]+]]:cherigpr = CIncOffsetImm [[LOADCAP_BigImm]], 1
  ; CHECK: bb.1.for.cond:
  ; CHECK:   successors: %bb.1(0x80000000)
  ; CHECK:   [[CAPLOAD3264_:%[0-9]+]]:gpr64 = CAPLOAD3264 [[DSLL]], 0, [[CIncOffsetImm]] :: (load (s32) from %ir.2, addrspace 200)
  ; CHECK:   [[DADDiu:%[0-9]+]]:gpr64 = nsw DADDiu killed [[CAPLOAD3264_]], 3
  ; CHECK:   [[CSetAddr:%[0-9]+]]:cherigpr = CSetAddr killed $cnull, killed [[DADDiu]]
  ; CHECK:   [[CAPLOAD8_:%[0-9]+]]:gpr64 = CAPLOAD8 $zero_64, 0, killed [[CSetAddr]] :: (load (s8) from %ir.5, addrspace 200)
  ; CHECK:   CAPSTORE8 killed [[CAPLOAD8_]], $zero_64, 1, [[CIncOffset]] :: (store (s8) into %ir.sunkaddr1, addrspace 200)
  ; CHECK:   B %bb.1, implicit-def dead $at
  bb.0.entry:
    successors: %bb.1(0x80000000)

    %1:cherigpr = PseudoPccRelativeAddressPostRA &_CHERI_CAPABILITY_TABLE_, implicit-def dead early-clobber %2
    %3:cherigpr = LOADCAP_BigImm target-flags(mips-captable20) @f, %1 :: (load (s128) from cap-table)
    %4:cherigpr = CIncOffsetImm %3, 6
    %5:gpr64 = CAPLOAD16 $zero_64, 0, killed %4 :: (load (s16) from `i16 addrspace(200)* getelementptr (%struct.d.0.1.2.3.6.7.32, %struct.d.0.1.2.3.6.7.32 addrspace(200)* bitcast (void () addrspace(200)* @f to %struct.d.0.1.2.3.6.7.32 addrspace(200)*), i64 0, i32 2, i64 0)`, addrspace 200)
    %6:gpr64 = DSLL killed %5, 3
    ; Previously the killed flag was not removed here even though the register was reused in the next basic block
    %0:cherigpr = CIncOffset %3, killed %6
    %7:cherigpr = CIncOffsetImm %0, 1

  bb.1.for.cond:
    successors: %bb.1(0x80000000)

    %8:gpr64 = CAPLOAD3264 $zero_64, 0, %7 :: (load (s32) from %ir.2, addrspace 200)
    %9:gpr64 = nsw DADDiu killed %8, 3
    %11:cherigpr = CSetAddr killed $cnull, killed %9
    %12:gpr64 = CAPLOAD8 $zero_64, 0, killed %11 :: (load (s8) from %ir.5, addrspace 200)
    CAPSTORE8 killed %12, $zero_64, 0, %7 :: (store (s8) into %ir.sunkaddr1, addrspace 200)
    B %bb.1, implicit-def dead $at

...
