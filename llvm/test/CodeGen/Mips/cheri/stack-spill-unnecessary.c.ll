; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; The new CheriBoundedStackPseudo instruction lets us pretend that the incoffset+csetbounds
; is a single trivially rematerizable instruction so it can freely move it around to avoid stack spills.
; we were moving the allocation of the register that is only used later to the beginning

; RUN: sed 's/addrspace(200)/addrspace(0)/g' %s | %cheri_llc -o - -O2 -verify-machineinstrs -relocation-model pic | FileCheck -check-prefix MIPS %s
; RUN: %cheri_purecap_llc %s -O2 -o - | %cheri_FileCheck %s


declare void @foo() addrspace(200)

declare void @bar(i32 addrspace(200)*) addrspace(200)

define void @foobar() addrspace(200) nounwind {
; MIPS-LABEL: foobar:
; MIPS:       # %bb.0: # %entry
; MIPS-NEXT:    daddiu $sp, $sp, -32
; MIPS-NEXT:    sd $ra, 24($sp) # 8-byte Folded Spill
; MIPS-NEXT:    sd $gp, 16($sp) # 8-byte Folded Spill
; MIPS-NEXT:    lui $1, %hi(%neg(%gp_rel(foobar)))
; MIPS-NEXT:    daddu $1, $1, $25
; MIPS-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(foobar)))
; MIPS-NEXT:    addiu $1, $zero, 123
; MIPS-NEXT:    sw $1, 12($sp)
; MIPS-NEXT:    ld $25, %call16(foo)($gp)
; MIPS-NEXT:    .reloc .Ltmp0, R_MIPS_JALR, foo
; MIPS-NEXT:  .Ltmp0:
; MIPS-NEXT:    jalr $25
; MIPS-NEXT:    nop
; MIPS-NEXT:    ld $25, %call16(bar)($gp)
; MIPS-NEXT:    .reloc .Ltmp1, R_MIPS_JALR, bar
; MIPS-NEXT:  .Ltmp1:
; MIPS-NEXT:    jalr $25
; MIPS-NEXT:    daddiu $4, $sp, 12
; MIPS-NEXT:    ld $gp, 16($sp) # 8-byte Folded Reload
; MIPS-NEXT:    ld $ra, 24($sp) # 8-byte Folded Reload
; MIPS-NEXT:    jr $ra
; MIPS-NEXT:    daddiu $sp, $sp, 32
;
; CHECK-LABEL: foobar:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -[[STACKFRAME_SIZE:48|96]]
; CHECK-NEXT:    csc $c18, $zero, [[#CAP_SIZE * 2]]($c11)
; CHECK-NEXT:    csc $c17, $zero, [[#CAP_SIZE * 1]]($c11)
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c18, $1
; CHECK-NEXT:    addiu $1, $zero, 123
; CHECK-NEXT:    csw $1, $zero, [[#CAP_SIZE - 4]]($c11)
; CHECK-NEXT:    clcbi $c12, %capcall20(foo)($c18)
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    nop
; CHECK-NEXT:    clcbi $c12, %capcall20(bar)($c18)
; CHECK-NEXT:    cincoffset $c3, $c11, [[#CAP_SIZE - 4]]
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    csetbounds $c3, $c3, 4
; CHECK-NEXT:    clc $c17, $zero, [[#CAP_SIZE * 1]]($c11)
; CHECK-NEXT:    clc $c18, $zero, [[#CAP_SIZE * 2]]($c11)
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, [[STACKFRAME_SIZE]]
entry:
  %x = alloca i32, align 4, addrspace(200)
  store i32 123, i32 addrspace(200)* %x, align 4
  call void @foo()
  call void @bar(i32 addrspace(200)* %x)
  ret void
}


define void @foobar_without_store() addrspace(200) nounwind {
; MIPS-LABEL: foobar_without_store:
; MIPS:       # %bb.0: # %entry
; MIPS-NEXT:    daddiu $sp, $sp, -32
; MIPS-NEXT:    sd $ra, 24($sp) # 8-byte Folded Spill
; MIPS-NEXT:    sd $gp, 16($sp) # 8-byte Folded Spill
; MIPS-NEXT:    lui $1, %hi(%neg(%gp_rel(foobar_without_store)))
; MIPS-NEXT:    daddu $1, $1, $25
; MIPS-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(foobar_without_store)))
; MIPS-NEXT:    ld $25, %call16(foo)($gp)
; MIPS-NEXT:    .reloc .Ltmp2, R_MIPS_JALR, foo
; MIPS-NEXT:  .Ltmp2:
; MIPS-NEXT:    jalr $25
; MIPS-NEXT:    nop
; MIPS-NEXT:    ld $25, %call16(bar)($gp)
; MIPS-NEXT:    .reloc .Ltmp3, R_MIPS_JALR, bar
; MIPS-NEXT:  .Ltmp3:
; MIPS-NEXT:    jalr $25
; MIPS-NEXT:    daddiu $4, $sp, 12
; MIPS-NEXT:    ld $25, %call16(bar)($gp)
; MIPS-NEXT:    .reloc .Ltmp4, R_MIPS_JALR, bar
; MIPS-NEXT:  .Ltmp4:
; MIPS-NEXT:    jalr $25
; MIPS-NEXT:    daddiu $4, $sp, 8
; MIPS-NEXT:    ld $gp, 16($sp) # 8-byte Folded Reload
; MIPS-NEXT:    ld $ra, 24($sp) # 8-byte Folded Reload
; MIPS-NEXT:    jr $ra
; MIPS-NEXT:    daddiu $sp, $sp, 32
;
; CHECK-LABEL: foobar_without_store:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -[[STACKFRAME_SIZE:48|96]]
; CHECK-NEXT:    csc $c18, $zero, [[#CAP_SIZE * 2]]($c11)
; CHECK-NEXT:    csc $c17, $zero, [[#CAP_SIZE * 1]]($c11)
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c18, $1
; CHECK-NEXT:    clcbi $c12, %capcall20(foo)($c18)
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    nop
; CHECK-NEXT:    clcbi $c12, %capcall20(bar)($c18)
; CHECK-NEXT:    cincoffset $c3, $c11, [[#CAP_SIZE - 4]]
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    csetbounds $c3, $c3, 4
; CHECK-NEXT:    clcbi $c12, %capcall20(bar)($c18)
; CHECK-NEXT:    cincoffset $c3, $c11, [[#CAP_SIZE - 8]]
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    csetbounds $c3, $c3, 4
; CHECK-NEXT:    clc $c17, $zero, [[#CAP_SIZE * 1]]($c11)
; CHECK-NEXT:    clc $c18, $zero, [[#CAP_SIZE * 2]]($c11)
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, [[STACKFRAME_SIZE]]
entry:
  %x = alloca i32, align 4, addrspace(200)
  %y = alloca i32, align 4, addrspace(200)
  call void @foo()
  call void @bar(i32 addrspace(200)* %x)
  call void @bar(i32 addrspace(200)* %y)
  ret void
}
