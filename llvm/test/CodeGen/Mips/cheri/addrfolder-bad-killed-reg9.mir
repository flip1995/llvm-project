# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
## Another machine verifier error found compiling libntp
## Previously %1 was marked as killed even though it should not be
# RUN: %cheri_purecap_llc -run-pass=cheriaddrmodefolder -verify-machineinstrs -o - %s | FileCheck %s
--- |
  ; ModuleID = '/Users/alex/cheri/llvm-project/llvm/test/CodeGen/Mips/cheri/_addrfolder-err.c-reduce.ll'
  source_filename = "/tmp/lprint-206d64.c"
  target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"
  target triple = "cheri-unknown-freebsd"

  module asm ".ident\09\22$FreeBSD$\22"

  %struct.foo = type { i32, i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)*, i64, i64, %struct.snork addrspace(200)*, %struct.snork addrspace(200)*, %struct.spam }
  %struct.snork = type { %struct.snork addrspace(200)*, i32, i16, i64, i64, [16 x i8], [128 x i8], [8 x i8] }
  %struct.spam = type { %struct.snork.0 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)*, %struct.spam addrspace(200)*, %struct.spam addrspace(200)*, i8 addrspace(200)*, i32, i32, [8 x i8] }
  %struct.snork.0 = type { %struct.eggs addrspace(200)*, i32, i32, i32, %struct.spam addrspace(200)*, i64, i32, i32, i32, i32, i32 }
  %struct.eggs = type { %struct.spam addrspace(200)*, i32, i32, [8 x i8] }

  @global = external local_unnamed_addr addrspace(200) global %struct.foo addrspace(200)*, align 16

  ; Function Attrs: nofree norecurse noreturn nounwind
  define dso_local void @bar() local_unnamed_addr addrspace(200) #0 {
  bb:
    br label %bb16.lr.ph

  bb16.lr.ph:                                       ; preds = %bb, %bb30
    %tmp9.0 = phi i32 [ undef, %bb ], [ %tmp33, %bb30 ]
    %tmp20 = load %struct.foo addrspace(200)*, %struct.foo addrspace(200)* addrspace(200)* @global, align 16
    br label %bb16

  bb16:                                             ; preds = %bb16.lr.ph, %bb28
    %tmp11.12 = phi %struct.spam addrspace(200)* [ null, %bb16.lr.ph ], [ %tmp11.2, %bb28 ]
    %0 = icmp eq i32 %tmp9.0, 0
    br i1 %0, label %bb28, label %bb19

  bb19:                                             ; preds = %bb16
    %1 = bitcast %struct.foo addrspace(200)* %tmp20 to i8 addrspace(200)*
    %sunkaddr = getelementptr inbounds i8, i8 addrspace(200)* %1, i64 176
    %2 = bitcast i8 addrspace(200)* %sunkaddr to %struct.snork.0 addrspace(200)* addrspace(200)*
    %tmp23 = load %struct.snork.0 addrspace(200)*, %struct.snork.0 addrspace(200)* addrspace(200)* %2, align 16
    %tmp24 = getelementptr inbounds %struct.snork.0, %struct.snork.0 addrspace(200)* %tmp23, i64 0, i32 5
    %tmp25 = load i64, i64 addrspace(200)* %tmp24, align 16
    %tmp26 = getelementptr inbounds i8, i8 addrspace(200)* null, i64 %tmp25
    %tmp27 = bitcast i8 addrspace(200)* %tmp26 to %struct.spam addrspace(200)*
    br label %bb28

  bb28:                                             ; preds = %bb16, %bb19
    %tmp11.2 = phi %struct.spam addrspace(200)* [ %tmp27, %bb19 ], [ %tmp11.12, %bb16 ]
    %tmp15 = icmp eq %struct.spam addrspace(200)* %tmp11.2, null
    br i1 %tmp15, label %bb30, label %bb16

  bb30:                                             ; preds = %bb28
    store i8 addrspace(200)* null, i8 addrspace(200)* addrspace(200)* inttoptr (i64 32 to i8 addrspace(200)* addrspace(200)*), align 32
    %tmp33 = shl i32 %tmp9.0, 1
    br label %bb16.lr.ph
  }

  attributes #0 = { nofree norecurse noreturn nounwind "use-soft-float"="true" }

  !llvm.ident = !{!0}

  !0 = !{!"clang version 10.0.0 (https://github.com/CTSRD-CHERI/llvm-project 6ec41c653f1255484f2466872e65ced5f7b9991c)"}

...
---
name:            bar
alignment:       8
exposesReturnsTwice: false
legalized:       false
regBankSelected: false
selected:        false
failedISel:      false
tracksRegLiveness: true
hasWinCFI:       false
registers:
  - { id: 0, class: gpr32, preferred-register: '' }
  - { id: 1, class: cherigpr, preferred-register: '' }
  - { id: 2, class: cherigpr, preferred-register: '' }
  - { id: 3, class: cherigpr, preferred-register: '' }
  - { id: 4, class: cherigpr, preferred-register: '' }
  - { id: 5, class: gpr32, preferred-register: '' }
  - { id: 6, class: gpr32, preferred-register: '' }
  - { id: 7, class: cherigpr, preferred-register: '' }
  - { id: 8, class: cherigpr, preferred-register: '' }
  - { id: 9, class: gpr64, preferred-register: '' }
  - { id: 10, class: cherigpr, preferred-register: '' }
  - { id: 11, class: cherigpr, preferred-register: '' }
  - { id: 12, class: cherigpr, preferred-register: '' }
  - { id: 13, class: cherigpr, preferred-register: '' }
  - { id: 14, class: gpr64, preferred-register: '' }
  - { id: 15, class: cherigpr, preferred-register: '' }
  - { id: 16, class: cherigpr, preferred-register: '' }
liveins:         []
frameInfo:
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        false
  stackProtector:  ''
  maxCallFrameSize: 4294967295
  cvBytesOfCalleeSavedRegisters: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
  localFrameSize:  0
  savePoint:       ''
  restorePoint:    ''
fixedStack:      []
stack:           []
callSites:       []
constants:       []
machineFunctionInfo: {}
body:             |
  ; CHECK-LABEL: name: bar
  ; CHECK: bb.0.bb:
  ; CHECK:   successors: %bb.1(0x80000000)
  ; CHECK:   [[PseudoPccRelativeAddressPostRA:%[0-9]+]]:cherigpr = PseudoPccRelativeAddressPostRA &_CHERI_CAPABILITY_TABLE_, implicit-def dead early-clobber %9
  ; CHECK:   [[DEF:%[0-9]+]]:gpr32 = IMPLICIT_DEF
  ; CHECK:   [[LOADCAP_BigImm:%[0-9]+]]:cherigpr = LOADCAP_BigImm target-flags(mips-captable20) @global, [[PseudoPccRelativeAddressPostRA]] :: (load (s128) from cap-table)
  ; CHECK: bb.1.bb16.lr.ph:
  ; CHECK:   successors: %bb.2(0x80000000)
  ; CHECK:   [[PHI:%[0-9]+]]:gpr32 = PHI [[DEF]], %bb.0, %5, %bb.5
  ; CHECK:   [[LOADCAP:%[0-9]+]]:cherigpr = LOADCAP $zero_64, 0, [[LOADCAP_BigImm]] :: (dereferenceable load (s128) from @global, addrspace 200)
  ; CHECK:   [[CMove:%[0-9]+]]:cherigpr = COPY $cnull
  ; CHECK: bb.2.bb16:
  ; CHECK:   successors: %bb.4(0x30000000), %bb.3(0x50000000)
  ; CHECK:   [[PHI1:%[0-9]+]]:cherigpr = PHI [[CMove]], %bb.1, %4, %bb.4
  ; CHECK:   BEQ [[PHI]], $zero, %bb.4, implicit-def dead $at
  ; CHECK:   B %bb.3, implicit-def dead $at
  ; CHECK: bb.3.bb19:
  ; CHECK:   successors: %bb.4(0x80000000)
  ; CHECK:   [[LOADCAP1:%[0-9]+]]:cherigpr = LOADCAP $zero_64, 176, [[LOADCAP]] :: (load (s128) from %ir.2, addrspace 200)
  ; CHECK:   [[CAPLOAD64_:%[0-9]+]]:gpr64 = CAPLOAD64 $zero_64, 48, killed [[LOADCAP1]] :: (load (s64) from %ir.tmp24, align 16, addrspace 200)
  ; CHECK:   [[CIncOffset:%[0-9]+]]:cherigpr = CIncOffset $cnull, killed [[CAPLOAD64_]]
  ; CHECK: bb.4.bb28:
  ; CHECK:   successors: %bb.5(0x04000000), %bb.2(0x7c000000)
  ; CHECK:   [[PHI2:%[0-9]+]]:cherigpr = PHI [[PHI1]], %bb.2, [[CIncOffset]], %bb.3
  ; CHECK:   CBNZ [[PHI2]], %bb.2, implicit-def dead $at
  ; CHECK:   B %bb.5, implicit-def dead $at
  ; CHECK: bb.5.bb30:
  ; CHECK:   successors: %bb.1(0x80000000)
  ; CHECK:   [[SLL:%[0-9]+]]:gpr32 = SLL [[PHI]], 1
  ; CHECK:   B %bb.1, implicit-def dead $at
  bb.0.bb:
    successors: %bb.1(0x80000000)

    %8:cherigpr = PseudoPccRelativeAddressPostRA &_CHERI_CAPABILITY_TABLE_, implicit-def dead early-clobber %9
    %6:gpr32 = IMPLICIT_DEF
    %10:cherigpr = LOADCAP_BigImm target-flags(mips-captable20) @global, %8 :: (load (s128) from cap-table)

  bb.1.bb16.lr.ph:
    successors: %bb.2(0x80000000)

    %0:gpr32 = PHI %6, %bb.0, %5, %bb.5
    %1:cherigpr = LOADCAP $zero_64, 0, %10 :: (dereferenceable load (s128) from @global, addrspace 200)
    %7:cherigpr = COPY $cnull

  bb.2.bb16:
    successors: %bb.4(0x30000000), %bb.3(0x50000000)

    %2:cherigpr = PHI %7, %bb.1, %4, %bb.4
    BEQ %0, $zero, %bb.4, implicit-def dead $at
    B %bb.3, implicit-def dead $at

  bb.3.bb19:
    successors: %bb.4(0x80000000)

    %11:cherigpr = CIncOffsetImm %1, 176
    %12:cherigpr = LOADCAP $zero_64, 0, killed %11 :: (load (s128) from %ir.2, addrspace 200)
    %13:cherigpr = CIncOffsetImm killed %12, 48
    %14:gpr64 = CAPLOAD64 $zero_64, 0, killed %13 :: (load (s64) from %ir.tmp24, align 16, addrspace 200)
    %3:cherigpr = CIncOffset $cnull, killed %14

  bb.4.bb28:
    successors: %bb.5(0x04000000), %bb.2(0x7c000000)

    %4:cherigpr = PHI %2, %bb.2, %3, %bb.3
    CBNZ %4, %bb.2, implicit-def dead $at
    B %bb.5, implicit-def dead $at

  bb.5.bb30:
    successors: %bb.1(0x80000000)
    %5:gpr32 = SLL %0, 1
    B %bb.1, implicit-def dead $at

...
