; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %cheri128_purecap_llc %s -o - -O2 | FileCheck %s '-D#CAP_SIZE=16'
; Regression test for a crash in Webkit where the tag bit for hash map keys was cleared due to
; inlined memcpy performing an unaligned csd that cleared the tag bit of the key member

%struct.PropertyMapEntryPadded = type { %struct.UniquedStringImpl addrspace(200)*, i32, i8, i8, [10 x i8] }
%struct.PropertyMapEntryNoPadding = type { %struct.UniquedStringImpl addrspace(200)*, i32, i8, i8 }
%struct.UniquedStringImpl = type opaque

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p200i8(i64, i8 addrspace(200)* nocapture) addrspace(200) #1
; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* nocapture writeonly, i8 addrspace(200)* nocapture readonly, i64, i1) addrspace(200) #1
; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p200i8(i64, i8 addrspace(200)* nocapture) addrspace(200) #1


declare %struct.PropertyMapEntryPadded addrspace(200)* @find_in_table(i32 signext) local_unnamed_addr addrspace(200) #2

; This performs two capability copies:
define i1 @insert_padded_test(%struct.PropertyMapEntryPadded addrspace(200)* nocapture readonly %key, i32 signext %index) local_unnamed_addr addrspace(200) #0 {
; CHECK-LABEL: insert_padded_test:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -[[STACKFRAME_SIZE:32|64]]
; CHECK-NEXT:    csc $c18, $zero, [[#CAP_SIZE * 1]]($c11)
; CHECK-NEXT:    csc $c17, $zero, 0($c11)
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c12, %capcall20(find_in_table)($c1)
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    cmove $c18, $c3
; CHECK-NEXT:    clc $c1, $zero, 0($c18)
; CHECK-NEXT:    csc $c1, $zero, 0($c3)
; CHECK-NEXT:    clc $c1, $zero, 16($c18)
; CHECK-NEXT:    addiu $2, $zero, 1
; CHECK-NEXT:    csc $c1, $zero, 16($c3)
; CHECK-NEXT:    clc $c17, $zero, 0($c11)
; CHECK-NEXT:    clc $c18, $zero, [[#CAP_SIZE * 1]]($c11)
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, [[STACKFRAME_SIZE]]
entry:
  %call = tail call %struct.PropertyMapEntryPadded addrspace(200)* @find_in_table(i32 signext %index) #3
  %0 = bitcast %struct.PropertyMapEntryPadded addrspace(200)* %call to i8 addrspace(200)*
  %1 = bitcast %struct.PropertyMapEntryPadded addrspace(200)* %key to i8 addrspace(200)*
  tail call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 16 %0, i8 addrspace(200)* nonnull align 16 %1, i64 32, i1 false)
  ret i1 1
}

; Ensure that we don't attempt to perfom a CIncOffset by 14 followed by an 8byte store for the last few bytes
; This was preivoulsy clearing the tag bit. Perform a 4byte store followed by a 2 byte one instead!
define i1 @insert_padded_but_copy_only_relevant_bytes(%struct.PropertyMapEntryPadded addrspace(200)* nocapture readonly %key, i32 signext %index) local_unnamed_addr addrspace(200) #0 {
; CHECK-LABEL: insert_padded_but_copy_only_relevant_bytes:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -[[STACKFRAME_SIZE:32|64]]
; CHECK-NEXT:    csc $c18, $zero, [[#CAP_SIZE * 1]]($c11)
; CHECK-NEXT:    csc $c17, $zero, 0($c11)
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c12, %capcall20(find_in_table)($c1)
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    cmove $c18, $c3
; CHECK-NEXT:    clc $c1, $zero, 0($c18)
; CHECK-NEXT:    csc $c1, $zero, 0($c3)
; CHECK-NEXT:    clc $c1, $zero, 16($c18)
; CHECK-NEXT:    addiu $2, $zero, 1
; CHECK-NEXT:    csc $c1, $zero, 16($c3)
; CHECK-NEXT:    clc $c17, $zero, 0($c11)
; CHECK-NEXT:    clc $c18, $zero, [[#CAP_SIZE * 1]]($c11)
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, [[STACKFRAME_SIZE]]
entry:
  %call = tail call %struct.PropertyMapEntryPadded addrspace(200)* @find_in_table(i32 signext %index) #3
  %0 = bitcast %struct.PropertyMapEntryPadded addrspace(200)* %call to i8 addrspace(200)*
  %1 = bitcast %struct.PropertyMapEntryPadded addrspace(200)* %key to i8 addrspace(200)*
  tail call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 16 %0, i8 addrspace(200)* nonnull align 16 %1, i64 32, i1 false)
  ret i1 1
}

declare %struct.PropertyMapEntryNoPadding addrspace(200)* @find_in_table_unpadded(i32 signext) local_unnamed_addr addrspace(200) #2
define i1 @insert_no_padding(%struct.PropertyMapEntryNoPadding addrspace(200)* nocapture readonly %key, i32 signext %index) local_unnamed_addr addrspace(200) #0 {
; CHECK-LABEL: insert_no_padding:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -[[STACKFRAME_SIZE:32|64]]
; CHECK-NEXT:    csc $c18, $zero, [[#CAP_SIZE * 1]]($c11)
; CHECK-NEXT:    csc $c17, $zero, 0($c11)
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c12, %capcall20(find_in_table_unpadded)($c1)
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    cmove $c18, $c3
; CHECK-NEXT:    clc $c1, $zero, 0($c18)
; CHECK-NEXT:    csc $c1, $zero, 0($c3)
; CHECK-NEXT:    clw $1, $zero, 16($c18)
; CHECK-NEXT:    csw $1, $zero, 16($c3)
; CHECK-NEXT:    clh $1, $zero, 20($c18)
; CHECK-NEXT:    addiu $2, $zero, 1
; CHECK-NEXT:    csh $1, $zero, 20($c3)
; CHECK-NEXT:    clc $c17, $zero, 0($c11)
; CHECK-NEXT:    clc $c18, $zero, [[#CAP_SIZE * 1]]($c11)
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, [[STACKFRAME_SIZE]]
entry:
  %call = tail call %struct.PropertyMapEntryNoPadding addrspace(200)* @find_in_table_unpadded(i32 signext %index) #3
  %0 = bitcast %struct.PropertyMapEntryNoPadding addrspace(200)* %call to i8 addrspace(200)*
  %1 = bitcast %struct.PropertyMapEntryNoPadding addrspace(200)* %key to i8 addrspace(200)*
  tail call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 16 %0, i8 addrspace(200)* nonnull align 16 %1, i64 22, i1 false)
  ret i1 1
}

attributes #0 = { nounwind }
attributes #1 = { argmemonly nounwind }
attributes #2 = { nounwind }
attributes #3 = { nounwind }
