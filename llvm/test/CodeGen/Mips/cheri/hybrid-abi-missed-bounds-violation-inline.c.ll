; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %cheri_llc -o - -stop-after=cheri-range-checker %s | FileCheck %s -check-prefix RANGE-CHECKER
; RUN: %cheri_llc -o - %s | FileCheck %s

; ModuleID = '/Users/alex/cheri/llvm-project/clang/test/CodeGen/cheri/hybrid-abi-missed-bounds-violation-inline.c'
@.str = private unnamed_addr constant [23 x i8] c"tag : %d, cap len: %d\0A\00", align 1
@.str.1 = private unnamed_addr constant [9 x i8] c"val: %d\0A\00", align 1

; Function Attrs: nounwind
define signext i32 @main2(i32 signext %argc, i8** nocapture readnone %argv) local_unnamed_addr nounwind {
; CHECK-LABEL: main2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -[[#STACKFRAME_SIZE:]]
; CHECK-NEXT:    sd $ra, 24($sp) # 8-byte Folded Spill
; CHECK-NEXT:    sd $16, 16($sp) # 8-byte Folded Spill
; CHECK-NEXT:    addiu $1, $zero, 7
; CHECK-NEXT:    sw $1, 12($sp)
; CHECK-NEXT:    daddiu $16, $sp, 12
; CHECK-NEXT:    cfromddc $c1, $16
; CHECK-NEXT:    csetbounds $c1, $c1, 4
; CHECK-NEXT:    cgetlen $1, $c1
; CHECK-NEXT:    cgettag $5, $c1
; CHECK-NEXT:    sll $6, $1, 0
; CHECK-NEXT:    lui $1, %highest(.L.str)
; CHECK-NEXT:    daddiu $1, $1, %higher(.L.str)
; CHECK-NEXT:    dsll $1, $1, 16
; CHECK-NEXT:    daddiu $1, $1, %hi(.L.str)
; CHECK-NEXT:    dsll $1, $1, 16
; CHECK-NEXT:    jal printf
; CHECK-NEXT:    daddiu $4, $1, %lo(.L.str)
; CHECK-NEXT:    lw $5, 4($16)
; CHECK-NEXT:    lui $1, %highest(.L.str.1)
; CHECK-NEXT:    daddiu $1, $1, %higher(.L.str.1)
; CHECK-NEXT:    dsll $1, $1, 16
; CHECK-NEXT:    daddiu $1, $1, %hi(.L.str.1)
; CHECK-NEXT:    dsll $1, $1, 16
; CHECK-NEXT:    jal printf
; CHECK-NEXT:    daddiu $4, $1, %lo(.L.str.1)
; CHECK-NEXT:    daddiu $2, $zero, 0
; CHECK-NEXT:    ld $16, 16($sp) # 8-byte Folded Reload
; CHECK-NEXT:    ld $ra, 24($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, [[#STACKFRAME_SIZE]]
entry:
  %i = alloca i32, align 4
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %0) #4
  store i32 7, i32* %i, align 4
  %1 = addrspacecast i8* %0 to i8 addrspace(200)*
  %2 = call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* %1)
  %conv = trunc i64 %2 to i32
  %3 = call i1 @llvm.cheri.cap.tag.get(i8 addrspace(200)* %1)
  %conv1 = zext i1 %3 to i32
  %call = call signext i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str, i64 0, i64 0), i32 signext %conv1, i32 signext %conv)
  %arrayidx8 = getelementptr inbounds i32, i32* %i, i64 1
  %arrayidx = addrspacecast i32* %arrayidx8 to i32 addrspace(200)*
  %4 = load i32, i32 addrspace(200)* %arrayidx, align 4
  %call2 = call signext i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i64 0, i64 0), i32 signext %4)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %0) #4
  ret i32 0
}

; RANGE-CHECKER-LABEL:  define signext i32 @main2(i32 signext %argc, i8** nocapture readnone %argv) local_unnamed_addr #0 {
; RANGE-CHECKER-NEXT:  entry:
; RANGE-CHECKER-NEXT:    %i = alloca i32, align 4
; RANGE-CHECKER-NEXT:    %0 = bitcast i32* %i to i8*
; RANGE-CHECKER-NEXT:    call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %0)
; RANGE-CHECKER-NEXT:    store i32 7, i32* %i, align 4
; RANGE-CHECKER-NEXT:    %1 = addrspacecast i8* %0 to i8 addrspace(200)*
; RANGE-CHECKER-NEXT:    %2 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* %1, i64 4)
; RANGE-CHECKER-NEXT:    %3 = call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* %2)
; RANGE-CHECKER-NEXT:    %conv = trunc i64 %3 to i32
; RANGE-CHECKER-NEXT:    %4 = call i1 @llvm.cheri.cap.tag.get(i8 addrspace(200)* %2)
; RANGE-CHECKER-NEXT:    %conv1 = zext i1 %4 to i32
; RANGE-CHECKER-NEXT:    %call = call signext i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str, i64 0, i64 0), i32 signext %conv1, i32 signext %conv)
; RANGE-CHECKER-NEXT:    %arrayidx8 = getelementptr inbounds i32, i32* %i, i64 1
; RANGE-CHECKER-NEXT:    %arrayidx = addrspacecast i32* %arrayidx8 to i32 addrspace(200)*
; RANGE-CHECKER-NEXT:    %5 = load i32, i32 addrspace(200)* %arrayidx, align 4
; RANGE-CHECKER-NEXT:    %call2 = call signext i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1, i64 0, i64 0), i32 signext %5)
; RANGE-CHECKER-NEXT:    call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %0)
; RANGE-CHECKER-NEXT:    ret i32 0
; RANGE-CHECKER-NEXT:  }

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #1

; Function Attrs: nounwind readnone
declare i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)*) #2

; Function Attrs: nounwind readnone
declare i1 @llvm.cheri.cap.tag.get(i8 addrspace(200)*) #2

; Function Attrs: nofree nounwind
declare signext i32 @printf(i8* nocapture readonly, ...) local_unnamed_addr #3

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #1
